import { _optionalChainDelete, _nullishCoalesce, _optionalChain } from '@sentry/utils';
import { context, SpanKind, trace, diag, DiagLogLevel } from '@opentelemetry/api';
import { HttpInstrumentation } from '@opentelemetry/instrumentation-http';
import { getScopesFromContext, addOpenTelemetryInstrumentation, getClient, getSpanKind, getRequestSpanData, wrapContextManagerClass, setupEventContextTrace, SentrySampler, SentrySpanProcessor, SentryPropagator, setOpenTelemetryContextAsyncContextStrategy, openTelemetrySetupCheck } from '@sentry/opentelemetry';
export { addOpenTelemetryInstrumentation, continueTrace, setOpenTelemetryContextAsyncContextStrategy as setNodeAsyncContextStrategy } from '@sentry/opentelemetry';
import { SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, defineIntegration, isSentryRequestUrl, getCapturedScopesOnSpan, getIsolationScope, getCurrentScope, setCapturedScopesOnSpan, spanToJSON, addBreadcrumb, getClient as getClient$1, captureException, getGlobalScope, mergeScopeData, getDefaultIsolationScope, SDK_VERSION, getActiveSpan, getRootSpan, SPAN_STATUS_ERROR, createTransport, suppressTracing, ServerRuntimeClient, applySdkMetadata, inboundFiltersIntegration, functionToStringIntegration, linkedErrorsIntegration, requestDataIntegration, hasTracingEnabled, getIntegrationsToSetup, startSession, endSession, withMonitor } from '@sentry/core';
export { SDK_VERSION, SEMANTIC_ATTRIBUTE_SENTRY_OP, SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE, Scope, addBreadcrumb, addEventProcessor, addIntegration, captureCheckIn, captureConsoleIntegration, captureEvent, captureException, captureFeedback, captureMessage, captureSession, close, createTransport, debugIntegration, dedupeIntegration, endSession, extraErrorDataIntegration, flush, functionToStringIntegration, getActiveSpan, getClient, getCurrentHub, getCurrentScope, getGlobalScope, getIsolationScope, getRootSpan, getSpanDescendants, getSpanStatusFromHttpCode, inboundFiltersIntegration, isInitialized, linkedErrorsIntegration, metricsDefault as metrics, parameterize, requestDataIntegration, rewriteFramesIntegration, sessionTimingIntegration, setContext, setCurrentClient, setExtra, setExtras, setHttpStatus, setMeasurement, setTag, setTags, setUser, spanToBaggageHeader, spanToJSON, spanToTraceHeader, startInactiveSpan, startSession, startSpan, startSpanManual, trpcMiddleware, withActiveSpan, withIsolationScope, withMonitor, withScope, zodErrorsIntegration } from '@sentry/core';
import { stripUrlQueryAndFragment, parseSemver, logger, addConsoleInstrumentationHandler, severityLevelFromString, LRUMap, addContextToFrame, consoleSandbox, GLOBAL_OBJ, serializeEnvelope, dirname as dirname$1, createStackParser, nodeStackLineParser, dropUndefinedKeys, stackParserFromStackParserOptions, propagationContextFromHeaders } from '@sentry/utils';
export { DEFAULT_USER_INCLUDES, addRequestDataToEvent, extractRequestData } from '@sentry/utils';
import * as util from 'util';
import { promisify } from 'util';
import { execFile } from 'child_process';
import { readFile, readdir, promises, existsSync, readFileSync } from 'fs';
import * as os from 'os';
import { join, dirname, posix, sep } from 'path';
import { Worker, isMainThread, threadId } from 'worker_threads';
import * as inspector from 'inspector';
import { Session } from 'inspector';
import { ExpressInstrumentation } from '@opentelemetry/instrumentation-express';
import { isWrapped as isWrapped$1 } from '@opentelemetry/core';
import { FastifyInstrumentation } from '@opentelemetry/instrumentation-fastify';
import { GraphQLInstrumentation } from '@opentelemetry/instrumentation-graphql';
import { MongoDBInstrumentation } from '@opentelemetry/instrumentation-mongodb';
import { MongooseInstrumentation } from '@opentelemetry/instrumentation-mongoose';
import { MySQLInstrumentation } from '@opentelemetry/instrumentation-mysql';
import { MySQL2Instrumentation } from '@opentelemetry/instrumentation-mysql2';
import { IORedisInstrumentation } from '@opentelemetry/instrumentation-ioredis';
import { NestInstrumentation } from '@opentelemetry/instrumentation-nestjs-core';
import { PgInstrumentation } from '@opentelemetry/instrumentation-pg';
import * as prismaInstrumentation from '@prisma/instrumentation';
import { HapiInstrumentation } from '@opentelemetry/instrumentation-hapi';
import { KoaInstrumentation } from '@opentelemetry/instrumentation-koa';
import { SEMATTRS_HTTP_ROUTE, SEMRESATTRS_SERVICE_NAME, SEMRESATTRS_SERVICE_NAMESPACE, SEMRESATTRS_SERVICE_VERSION } from '@opentelemetry/semantic-conventions';
import { ConnectInstrumentation } from '@opentelemetry/instrumentation-connect';
import * as http from 'http';
import moduleModule from 'module';
import * as http$1 from 'node:http';
import * as https from 'node:https';
import { Readable } from 'stream';
import { createGzip } from 'zlib';
import * as net from 'net';
import * as tls from 'tls';
import { Resource } from '@opentelemetry/resources';
import { BasicTracerProvider } from '@opentelemetry/sdk-trace-base';
import { AsyncLocalStorageContextManager } from '@opentelemetry/context-async-hooks';

/**
 * Update the active isolation scope.
 * Should be used with caution!
 */
function setIsolationScope(isolationScope) {
  const scopes = getScopesFromContext(context.active());
  if (scopes) {
    scopes.isolationScope = isolationScope;
  }
}

/** Adds an origin to an OTEL Span. */
function addOriginToSpan(span, origin) {
  span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, origin);
}

/** Build a full URL from request options. */
function getRequestUrl(requestOptions) {
  const protocol = requestOptions.protocol || '';
  const hostname = requestOptions.hostname || requestOptions.host || '';
  // Don't log standard :80 (http) and :443 (https) ports to reduce the noise
  // Also don't add port if the hostname already includes a port
  const port =
    !requestOptions.port || requestOptions.port === 80 || requestOptions.port === 443 || /^(.*):(\d+)$/.test(hostname)
      ? ''
      : `:${requestOptions.port}`;
  const path = requestOptions.path ? requestOptions.path : '/';
  return `${protocol}//${hostname}${port}${path}`;
}

function _optionalChain$e(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

const _httpIntegration = ((options = {}) => {
  const _breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;
  const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;
  const _ignoreIncomingRequests = options.ignoreIncomingRequests;
  const _InstrumentationClass = options._instrumentation || HttpInstrumentation;

  return {
    name: 'Http',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        new _InstrumentationClass({
          ignoreOutgoingRequestHook: request => {
            const url = getRequestUrl(request);

            if (!url) {
              return false;
            }

            if (isSentryRequestUrl(url, getClient())) {
              return true;
            }

            if (_ignoreOutgoingRequests && _ignoreOutgoingRequests(url)) {
              return true;
            }

            return false;
          },

          ignoreIncomingRequestHook: request => {
            const url = getRequestUrl(request);

            const method = _optionalChain$e([request, 'access', _ => _.method, 'optionalAccess', _2 => _2.toUpperCase, 'call', _3 => _3()]);
            // We do not capture OPTIONS/HEAD requests as transactions
            if (method === 'OPTIONS' || method === 'HEAD') {
              return true;
            }

            if (_ignoreIncomingRequests && _ignoreIncomingRequests(url)) {
              return true;
            }

            return false;
          },

          requireParentforOutgoingSpans: false,
          requireParentforIncomingSpans: false,
          requestHook: (span, req) => {
            addOriginToSpan(span, 'auto.http.otel.http');

            // both, incoming requests and "client" requests made within the app trigger the requestHook
            // we only want to isolate and further annotate incoming requests (IncomingMessage)
            if (_isClientRequest(req)) {
              return;
            }

            const scopes = getCapturedScopesOnSpan(span);

            const isolationScope = (scopes.isolationScope || getIsolationScope()).clone();
            const scope = scopes.scope || getCurrentScope();

            // Update the isolation scope, isolate this request
            isolationScope.setSDKProcessingMetadata({ request: req });

            const client = getClient();
            if (client && client.getOptions().autoSessionTracking) {
              isolationScope.setRequestSession({ status: 'ok' });
            }
            setIsolationScope(isolationScope);
            setCapturedScopesOnSpan(span, scope, isolationScope);

            // attempt to update the scope's `transactionName` based on the request URL
            // Ideally, framework instrumentations coming after the HttpInstrumentation
            // update the transactionName once we get a parameterized route.
            const attributes = spanToJSON(span).data;
            if (!attributes) {
              return;
            }

            const httpMethod = String(attributes['http.method']).toUpperCase() || 'GET';
            const httpTarget = stripUrlQueryAndFragment(String(attributes['http.target'])) || '/';
            const bestEffortTransactionName = `${httpMethod} ${httpTarget}`;

            isolationScope.setTransactionName(bestEffortTransactionName);
          },
          responseHook: (span, res) => {
            if (_breadcrumbs) {
              _addRequestBreadcrumb$1(span, res);
            }

            const client = getClient();
            if (client && client.getOptions().autoSessionTracking) {
              setImmediate(() => {
                client['_captureRequestSession']();
              });
            }
          },
        }),
      );
    },
  };
}) ;

/**
 * The http integration instruments Node's internal http and https modules.
 * It creates breadcrumbs and spans for outgoing HTTP requests which will be attached to the currently active span.
 */
const httpIntegration = defineIntegration(_httpIntegration);

/** Add a breadcrumb for outgoing requests. */
function _addRequestBreadcrumb$1(span, response) {
  if (getSpanKind(span) !== SpanKind.CLIENT) {
    return;
  }

  const data = getRequestSpanData(span);
  addBreadcrumb(
    {
      category: 'http',
      data: {
        status_code: response.statusCode,
        ...data,
      },
      type: 'http',
    },
    {
      event: 'response',
      // TODO FN: Do we need access to `request` here?
      // If we do, we'll have to use the `applyCustomAttributesOnSpan` hook instead,
      // but this has worse context semantics than request/responseHook.
      response,
    },
  );
}

/**
 * Determines if @param req is a ClientRequest, meaning the request was created within the express app
 * and it's an outgoing request.
 * Checking for properties instead of using `instanceOf` to avoid importing the request classes.
 */
function _isClientRequest(req) {
  return 'outputData' in req && 'outputSize' in req && !('client' in req) && !('statusCode' in req);
}

/**
 * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.
 *
 * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.
 */
const DEBUG_BUILD = (typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__);

const NODE_VERSION = parseSemver(process.versions.node) ;
const NODE_MAJOR = NODE_VERSION.major;

const _nativeNodeFetchIntegration = ((options = {}) => {
  const _breadcrumbs = typeof options.breadcrumbs === 'undefined' ? true : options.breadcrumbs;
  const _ignoreOutgoingRequests = options.ignoreOutgoingRequests;

  async function getInstrumentation() {
    // Only add NodeFetch if Node >= 18, as previous versions do not support it
    if (NODE_MAJOR < 18) {
      DEBUG_BUILD && logger.log('NodeFetch is not supported on Node < 18, skipping instrumentation...');
      return;
    }

    try {
      const pkg = await import('opentelemetry-instrumentation-fetch-node');
      return new pkg.FetchInstrumentation({
        ignoreRequestHook: (request) => {
          const url = request.origin;
          return _ignoreOutgoingRequests && url && _ignoreOutgoingRequests(url);
        },
        onRequest: ({ span }) => {
          _updateSpan(span);

          if (_breadcrumbs) {
            _addRequestBreadcrumb(span);
          }
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
      } );
    } catch (error) {
      // Could not load instrumentation
      DEBUG_BUILD && logger.log('Could not load NodeFetch instrumentation.');
    }
  }

  return {
    name: 'NodeFetch',
    setupOnce() {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      getInstrumentation().then(instrumentation => {
        if (instrumentation) {
          addOpenTelemetryInstrumentation(instrumentation);
        }
      });
    },
  };
}) ;

const nativeNodeFetchIntegration = defineIntegration(_nativeNodeFetchIntegration);

/** Update the span with data we need. */
function _updateSpan(span) {
  addOriginToSpan(span, 'auto.http.otel.node_fetch');
}

/** Add a breadcrumb for outgoing requests. */
function _addRequestBreadcrumb(span) {
  if (getSpanKind(span) !== SpanKind.CLIENT) {
    return;
  }

  const data = getRequestSpanData(span);
  addBreadcrumb({
    category: 'http',
    data: {
      ...data,
    },
    type: 'http',
  });
}

const INTEGRATION_NAME$8 = 'Console';

const _consoleIntegration = (() => {
  return {
    name: INTEGRATION_NAME$8,
    setup(client) {
      addConsoleInstrumentationHandler(({ args, level }) => {
        if (getClient$1() !== client) {
          return;
        }

        addBreadcrumb(
          {
            category: 'console',
            level: severityLevelFromString(level),
            message: util.format.apply(undefined, args),
          },
          {
            input: [...args],
            level,
          },
        );
      });
    },
  };
}) ;

/**
 * Capture console logs as breadcrumbs.
 */
const consoleIntegration = defineIntegration(_consoleIntegration);

function _optionalChain$d(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
const readFileAsync$1 = promisify(readFile);
const readDirAsync = promisify(readdir);

const INTEGRATION_NAME$7 = 'Context';

const _nodeContextIntegration = ((options = {}) => {
  let cachedContext;

  const _options = {
    app: true,
    os: true,
    device: true,
    culture: true,
    cloudResource: true,
    ...options,
  };

  /** Add contexts to the event. Caches the context so we only look it up once. */
  async function addContext(event) {
    if (cachedContext === undefined) {
      cachedContext = _getContexts();
    }

    const updatedContext = _updateContext(await cachedContext);

    event.contexts = {
      ...event.contexts,
      app: { ...updatedContext.app, ..._optionalChain$d([event, 'access', _ => _.contexts, 'optionalAccess', _2 => _2.app]) },
      os: { ...updatedContext.os, ..._optionalChain$d([event, 'access', _3 => _3.contexts, 'optionalAccess', _4 => _4.os]) },
      device: { ...updatedContext.device, ..._optionalChain$d([event, 'access', _5 => _5.contexts, 'optionalAccess', _6 => _6.device]) },
      culture: { ...updatedContext.culture, ..._optionalChain$d([event, 'access', _7 => _7.contexts, 'optionalAccess', _8 => _8.culture]) },
      cloud_resource: { ...updatedContext.cloud_resource, ..._optionalChain$d([event, 'access', _9 => _9.contexts, 'optionalAccess', _10 => _10.cloud_resource]) },
    };

    return event;
  }

  /** Get the contexts from node. */
  async function _getContexts() {
    const contexts = {};

    if (_options.os) {
      contexts.os = await getOsContext();
    }

    if (_options.app) {
      contexts.app = getAppContext();
    }

    if (_options.device) {
      contexts.device = getDeviceContext(_options.device);
    }

    if (_options.culture) {
      const culture = getCultureContext();

      if (culture) {
        contexts.culture = culture;
      }
    }

    if (_options.cloudResource) {
      contexts.cloud_resource = getCloudResourceContext();
    }

    return contexts;
  }

  return {
    name: INTEGRATION_NAME$7,
    processEvent(event) {
      return addContext(event);
    },
  };
}) ;

/**
 * Capture context about the environment and the device that the client is running on, to events.
 */
const nodeContextIntegration = defineIntegration(_nodeContextIntegration);

/**
 * Updates the context with dynamic values that can change
 */
function _updateContext(contexts) {
  // Only update properties if they exist
  if (_optionalChain$d([contexts, 'optionalAccess', _11 => _11.app, 'optionalAccess', _12 => _12.app_memory])) {
    contexts.app.app_memory = process.memoryUsage().rss;
  }

  if (_optionalChain$d([contexts, 'optionalAccess', _13 => _13.device, 'optionalAccess', _14 => _14.free_memory])) {
    contexts.device.free_memory = os.freemem();
  }

  return contexts;
}

/**
 * Returns the operating system context.
 *
 * Based on the current platform, this uses a different strategy to provide the
 * most accurate OS information. Since this might involve spawning subprocesses
 * or accessing the file system, this should only be executed lazily and cached.
 *
 *  - On macOS (Darwin), this will execute the `sw_vers` utility. The context
 *    has a `name`, `version`, `build` and `kernel_version` set.
 *  - On Linux, this will try to load a distribution release from `/etc` and set
 *    the `name`, `version` and `kernel_version` fields.
 *  - On all other platforms, only a `name` and `version` will be returned. Note
 *    that `version` might actually be the kernel version.
 */
async function getOsContext() {
  const platformId = os.platform();
  switch (platformId) {
    case 'darwin':
      return getDarwinInfo();
    case 'linux':
      return getLinuxInfo();
    default:
      return {
        name: PLATFORM_NAMES[platformId] || platformId,
        version: os.release(),
      };
  }
}

function getCultureContext() {
  try {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any
    if (typeof (process.versions ).icu !== 'string') {
      // Node was built without ICU support
      return;
    }

    // Check that node was built with full Intl support. Its possible it was built without support for non-English
    // locales which will make resolvedOptions inaccurate
    //
    // https://nodejs.org/api/intl.html#detecting-internationalization-support
    const january = new Date(9e8);
    const spanish = new Intl.DateTimeFormat('es', { month: 'long' });
    if (spanish.format(january) === 'enero') {
      const options = Intl.DateTimeFormat().resolvedOptions();

      return {
        locale: options.locale,
        timezone: options.timeZone,
      };
    }
  } catch (err) {
    //
  }

  return;
}

function getAppContext() {
  const app_memory = process.memoryUsage().rss;
  const app_start_time = new Date(Date.now() - process.uptime() * 1000).toISOString();

  return { app_start_time, app_memory };
}

/**
 * Gets device information from os
 */
function getDeviceContext(deviceOpt) {
  const device = {};

  // Sometimes os.uptime() throws due to lacking permissions: https://github.com/getsentry/sentry-javascript/issues/8202
  let uptime;
  try {
    uptime = os.uptime && os.uptime();
  } catch (e) {
    // noop
  }

  // os.uptime or its return value seem to be undefined in certain environments (e.g. Azure functions).
  // Hence, we only set boot time, if we get a valid uptime value.
  // @see https://github.com/getsentry/sentry-javascript/issues/5856
  if (typeof uptime === 'number') {
    device.boot_time = new Date(Date.now() - uptime * 1000).toISOString();
  }

  device.arch = os.arch();

  if (deviceOpt === true || deviceOpt.memory) {
    device.memory_size = os.totalmem();
    device.free_memory = os.freemem();
  }

  if (deviceOpt === true || deviceOpt.cpu) {
    const cpuInfo = os.cpus();
    if (cpuInfo && cpuInfo.length) {
      const firstCpu = cpuInfo[0];

      device.processor_count = cpuInfo.length;
      device.cpu_description = firstCpu.model;
      device.processor_frequency = firstCpu.speed;
    }
  }

  return device;
}

/** Mapping of Node's platform names to actual OS names. */
const PLATFORM_NAMES = {
  aix: 'IBM AIX',
  freebsd: 'FreeBSD',
  openbsd: 'OpenBSD',
  sunos: 'SunOS',
  win32: 'Windows',
};

/** Linux version file to check for a distribution. */

/** Mapping of linux release files located in /etc to distributions. */
const LINUX_DISTROS = [
  { name: 'fedora-release', distros: ['Fedora'] },
  { name: 'redhat-release', distros: ['Red Hat Linux', 'Centos'] },
  { name: 'redhat_version', distros: ['Red Hat Linux'] },
  { name: 'SuSE-release', distros: ['SUSE Linux'] },
  { name: 'lsb-release', distros: ['Ubuntu Linux', 'Arch Linux'] },
  { name: 'debian_version', distros: ['Debian'] },
  { name: 'debian_release', distros: ['Debian'] },
  { name: 'arch-release', distros: ['Arch Linux'] },
  { name: 'gentoo-release', distros: ['Gentoo Linux'] },
  { name: 'novell-release', distros: ['SUSE Linux'] },
  { name: 'alpine-release', distros: ['Alpine Linux'] },
];

/** Functions to extract the OS version from Linux release files. */
const LINUX_VERSIONS

 = {
  alpine: content => content,
  arch: content => matchFirst(/distrib_release=(.*)/, content),
  centos: content => matchFirst(/release ([^ ]+)/, content),
  debian: content => content,
  fedora: content => matchFirst(/release (..)/, content),
  mint: content => matchFirst(/distrib_release=(.*)/, content),
  red: content => matchFirst(/release ([^ ]+)/, content),
  suse: content => matchFirst(/VERSION = (.*)\n/, content),
  ubuntu: content => matchFirst(/distrib_release=(.*)/, content),
};

/**
 * Executes a regular expression with one capture group.
 *
 * @param regex A regular expression to execute.
 * @param text Content to execute the RegEx on.
 * @returns The captured string if matched; otherwise undefined.
 */
function matchFirst(regex, text) {
  const match = regex.exec(text);
  return match ? match[1] : undefined;
}

/** Loads the macOS operating system context. */
async function getDarwinInfo() {
  // Default values that will be used in case no operating system information
  // can be loaded. The default version is computed via heuristics from the
  // kernel version, but the build ID is missing.
  const darwinInfo = {
    kernel_version: os.release(),
    name: 'Mac OS X',
    version: `10.${Number(os.release().split('.')[0]) - 4}`,
  };

  try {
    // We try to load the actual macOS version by executing the `sw_vers` tool.
    // This tool should be available on every standard macOS installation. In
    // case this fails, we stick with the values computed above.

    const output = await new Promise((resolve, reject) => {
      execFile('/usr/bin/sw_vers', (error, stdout) => {
        if (error) {
          reject(error);
          return;
        }
        resolve(stdout);
      });
    });

    darwinInfo.name = matchFirst(/^ProductName:\s+(.*)$/m, output);
    darwinInfo.version = matchFirst(/^ProductVersion:\s+(.*)$/m, output);
    darwinInfo.build = matchFirst(/^BuildVersion:\s+(.*)$/m, output);
  } catch (e) {
    // ignore
  }

  return darwinInfo;
}

/** Returns a distribution identifier to look up version callbacks. */
function getLinuxDistroId(name) {
  return name.split(' ')[0].toLowerCase();
}

/** Loads the Linux operating system context. */
async function getLinuxInfo() {
  // By default, we cannot assume anything about the distribution or Linux
  // version. `os.release()` returns the kernel version and we assume a generic
  // "Linux" name, which will be replaced down below.
  const linuxInfo = {
    kernel_version: os.release(),
    name: 'Linux',
  };

  try {
    // We start guessing the distribution by listing files in the /etc
    // directory. This is were most Linux distributions (except Knoppix) store
    // release files with certain distribution-dependent meta data. We search
    // for exactly one known file defined in `LINUX_DISTROS` and exit if none
    // are found. In case there are more than one file, we just stick with the
    // first one.
    const etcFiles = await readDirAsync('/etc');
    const distroFile = LINUX_DISTROS.find(file => etcFiles.includes(file.name));
    if (!distroFile) {
      return linuxInfo;
    }

    // Once that file is known, load its contents. To make searching in those
    // files easier, we lowercase the file contents. Since these files are
    // usually quite small, this should not allocate too much memory and we only
    // hold on to it for a very short amount of time.
    const distroPath = join('/etc', distroFile.name);
    const contents = ((await readFileAsync$1(distroPath, { encoding: 'utf-8' })) ).toLowerCase();

    // Some Linux distributions store their release information in the same file
    // (e.g. RHEL and Centos). In those cases, we scan the file for an
    // identifier, that basically consists of the first word of the linux
    // distribution name (e.g. "red" for Red Hat). In case there is no match, we
    // just assume the first distribution in our list.
    const { distros } = distroFile;
    linuxInfo.name = distros.find(d => contents.indexOf(getLinuxDistroId(d)) >= 0) || distros[0];

    // Based on the found distribution, we can now compute the actual version
    // number. This is different for every distribution, so several strategies
    // are computed in `LINUX_VERSIONS`.
    const id = getLinuxDistroId(linuxInfo.name);
    linuxInfo.version = LINUX_VERSIONS[id](contents);
  } catch (e) {
    // ignore
  }

  return linuxInfo;
}

/**
 * Grabs some information about hosting provider based on best effort.
 */
function getCloudResourceContext() {
  if (process.env.VERCEL) {
    // https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables
    return {
      'cloud.provider': 'vercel',
      'cloud.region': process.env.VERCEL_REGION,
    };
  } else if (process.env.AWS_REGION) {
    // https://docs.aws.amazon.com/lambda/latest/dg/configuration-envvars.html
    return {
      'cloud.provider': 'aws',
      'cloud.region': process.env.AWS_REGION,
      'cloud.platform': process.env.AWS_EXECUTION_ENV,
    };
  } else if (process.env.GCP_PROJECT) {
    // https://cloud.google.com/composer/docs/how-to/managing/environment-variables#reserved_variables
    return {
      'cloud.provider': 'gcp',
    };
  } else if (process.env.ALIYUN_REGION_ID) {
    // TODO: find where I found these environment variables - at least gc.github.com returns something
    return {
      'cloud.provider': 'alibaba_cloud',
      'cloud.region': process.env.ALIYUN_REGION_ID,
    };
  } else if (process.env.WEBSITE_SITE_NAME && process.env.REGION_NAME) {
    // https://learn.microsoft.com/en-us/azure/app-service/reference-app-settings?tabs=kudu%2Cdotnet#app-environment
    return {
      'cloud.provider': 'azure',
      'cloud.region': process.env.REGION_NAME,
    };
  } else if (process.env.IBM_CLOUD_REGION) {
    // TODO: find where I found these environment variables - at least gc.github.com returns something
    return {
      'cloud.provider': 'ibm_cloud',
      'cloud.region': process.env.IBM_CLOUD_REGION,
    };
  } else if (process.env.TENCENTCLOUD_REGION) {
    // https://www.tencentcloud.com/document/product/583/32748
    return {
      'cloud.provider': 'tencent_cloud',
      'cloud.region': process.env.TENCENTCLOUD_REGION,
      'cloud.account.id': process.env.TENCENTCLOUD_APPID,
      'cloud.availability_zone': process.env.TENCENTCLOUD_ZONE,
    };
  } else if (process.env.NETLIFY) {
    // https://docs.netlify.com/configure-builds/environment-variables/#read-only-variables
    return {
      'cloud.provider': 'netlify',
    };
  } else if (process.env.FLY_REGION) {
    // https://fly.io/docs/reference/runtime-environment/
    return {
      'cloud.provider': 'fly.io',
      'cloud.region': process.env.FLY_REGION,
    };
  } else if (process.env.DYNO) {
    // https://devcenter.heroku.com/articles/dynos#local-environment-variables
    return {
      'cloud.provider': 'heroku',
    };
  } else {
    return undefined;
  }
}

function _optionalChain$c(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
const FILE_CONTENT_CACHE = new LRUMap(100);
const DEFAULT_LINES_OF_CONTEXT = 7;
const INTEGRATION_NAME$6 = 'ContextLines';

const readFileAsync = promises.readFile;

/** Exported only for tests, as a type-safe variant. */
const _contextLinesIntegration = ((options = {}) => {
  const contextLines = options.frameContextLines !== undefined ? options.frameContextLines : DEFAULT_LINES_OF_CONTEXT;

  return {
    name: INTEGRATION_NAME$6,
    processEvent(event) {
      return addSourceContext(event, contextLines);
    },
  };
}) ;

/**
 * Capture the lines before and after the frame's context.
 */
const contextLinesIntegration = defineIntegration(_contextLinesIntegration);

async function addSourceContext(event, contextLines) {
  // keep a lookup map of which files we've already enqueued to read,
  // so we don't enqueue the same file multiple times which would cause multiple i/o reads
  const enqueuedReadSourceFileTasks = {};
  const readSourceFileTasks = [];

  if (contextLines > 0 && _optionalChain$c([event, 'access', _2 => _2.exception, 'optionalAccess', _3 => _3.values])) {
    for (const exception of event.exception.values) {
      if (!_optionalChain$c([exception, 'access', _4 => _4.stacktrace, 'optionalAccess', _5 => _5.frames])) {
        continue;
      }

      // We want to iterate in reverse order as calling cache.get will bump the file in our LRU cache.
      // This ends up prioritizes source context for frames at the top of the stack instead of the bottom.
      for (let i = exception.stacktrace.frames.length - 1; i >= 0; i--) {
        const frame = exception.stacktrace.frames[i];
        // Call cache.get to bump the file to the top of the cache and ensure we have not already
        // enqueued a read operation for this filename
        if (frame.filename && !enqueuedReadSourceFileTasks[frame.filename] && !FILE_CONTENT_CACHE.get(frame.filename)) {
          readSourceFileTasks.push(_readSourceFile(frame.filename));
          enqueuedReadSourceFileTasks[frame.filename] = 1;
        }
      }
    }
  }

  // check if files to read > 0, if so, await all of them to be read before adding source contexts.
  // Normally, Promise.all here could be short circuited if one of the promises rejects, but we
  // are guarding from that by wrapping the i/o read operation in a try/catch.
  if (readSourceFileTasks.length > 0) {
    await Promise.all(readSourceFileTasks);
  }

  // Perform the same loop as above, but this time we can assume all files are in the cache
  // and attempt to add source context to frames.
  if (contextLines > 0 && _optionalChain$c([event, 'access', _6 => _6.exception, 'optionalAccess', _7 => _7.values])) {
    for (const exception of event.exception.values) {
      if (exception.stacktrace && exception.stacktrace.frames) {
        await addSourceContextToFrames(exception.stacktrace.frames, contextLines);
      }
    }
  }

  return event;
}

/** Adds context lines to frames */
function addSourceContextToFrames(frames, contextLines) {
  for (const frame of frames) {
    // Only add context if we have a filename and it hasn't already been added
    if (frame.filename && frame.context_line === undefined) {
      const sourceFileLines = FILE_CONTENT_CACHE.get(frame.filename);

      if (sourceFileLines) {
        try {
          addContextToFrame(sourceFileLines, frame, contextLines);
        } catch (e) {
          // anomaly, being defensive in case
          // unlikely to ever happen in practice but can definitely happen in theory
        }
      }
    }
  }
}

/**
 * Reads file contents and caches them in a global LRU cache.
 * If reading fails, mark the file as null in the cache so we don't try again.
 *
 * @param filename filepath to read content from.
 */
async function _readSourceFile(filename) {
  const cachedFile = FILE_CONTENT_CACHE.get(filename);

  // We have already attempted to read this file and failed, do not try again
  if (cachedFile === null) {
    return null;
  }

  // We have a cache hit, return it
  if (cachedFile !== undefined) {
    return cachedFile;
  }

  // Guard from throwing if readFile fails, this enables us to use Promise.all and
  // not have it short circuiting if one of the promises rejects + since context lines are added
  // on a best effort basis, we want to throw here anyways.

  // If we made it to here, it means that our file is not cache nor marked as failed, so attempt to read it
  let content = null;
  try {
    const rawFileContents = await readFileAsync(filename, 'utf-8');
    content = rawFileContents.split('\n');
  } catch (_) {
    // if we fail, we will mark the file as null in the cache and short circuit next time we try to read it
  }

  FILE_CONTENT_CACHE.set(filename, content);
  return content;
}

/**
 * Creates a rate limiter that will call the disable callback when the rate limit is reached and the enable callback
 * when a timeout has occurred.
 * @param maxPerSecond Maximum number of calls per second
 * @param enable Callback to enable capture
 * @param disable Callback to disable capture
 * @returns A function to call to increment the rate limiter count
 */
function createRateLimiter(
  maxPerSecond,
  enable,
  disable,
) {
  let count = 0;
  let retrySeconds = 5;
  let disabledTimeout = 0;

  setInterval(() => {
    if (disabledTimeout === 0) {
      if (count > maxPerSecond) {
        retrySeconds *= 2;
        disable(retrySeconds);

        // Cap at one day
        if (retrySeconds > 86400) {
          retrySeconds = 86400;
        }
        disabledTimeout = retrySeconds;
      }
    } else {
      disabledTimeout -= 1;

      if (disabledTimeout === 0) {
        enable();
      }
    }

    count = 0;
  }, 1000).unref();

  return () => {
    count += 1;
  };
}

// Add types for the exception event data

/** Could this be an anonymous function? */
function isAnonymous(name) {
  return name !== undefined && (name.length === 0 || name === '?' || name === '<anonymous>');
}

/** Do the function names appear to match? */
function functionNamesMatch(a, b) {
  return a === b || (isAnonymous(a) && isAnonymous(b));
}

/** Creates a unique hash from stack frames */
function hashFrames(frames) {
  if (frames === undefined) {
    return;
  }

  // Only hash the 10 most recent frames (ie. the last 10)
  return frames.slice(-10).reduce((acc, frame) => `${acc},${frame.function},${frame.lineno},${frame.colno}`, '');
}

/**
 * We use the stack parser to create a unique hash from the exception stack trace
 * This is used to lookup vars when the exception passes through the event processor
 */
function hashFromStack(stackParser, stack) {
  if (stack === undefined) {
    return undefined;
  }

  return hashFrames(stackParser(stack, 1));
}

function _optionalChain$b(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
// This string is a placeholder that gets overwritten with the worker code.
const base64WorkerScript$1 = 'LyohIEBzZW50cnkvbm9kZSA4LjAuMCAoYzMzNmIxMSkgfCBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0ICovCmltcG9ydHtTZXNzaW9uIGFzIGV9ZnJvbSJub2RlOmluc3BlY3Rvci9wcm9taXNlcyI7aW1wb3J0e3dvcmtlckRhdGEgYXMgbixwYXJlbnRQb3J0IGFzIHR9ZnJvbSJ3b3JrZXJfdGhyZWFkcyI7aW1wb3J0e3Bvc2l4IGFzIG8sc2VwIGFzIHJ9ZnJvbSJwYXRoIjtjb25zdCBpPTUwLHM9Ij8iLGM9L1woZXJyb3I6ICguKilcKS8sYT0vY2FwdHVyZU1lc3NhZ2V8Y2FwdHVyZUV4Y2VwdGlvbi87Y29uc3QgdT0vXihcUys6XFx8XC8/KShbXHNcU10qPykoKD86XC57MSwyfXxbXi9cXF0rP3wpKFwuW14uL1xcXSp8KSkoPzpbL1xcXSopJC87ZnVuY3Rpb24gZihlKXtjb25zdCBuPWZ1bmN0aW9uKGUpe2NvbnN0IG49ZS5sZW5ndGg+MTAyND9gPHRydW5jYXRlZD4ke2Uuc2xpY2UoLTEwMjQpfWA6ZSx0PXUuZXhlYyhuKTtyZXR1cm4gdD90LnNsaWNlKDEpOltdfShlKSx0PW5bMF07bGV0IG89blsxXTtyZXR1cm4gdHx8bz8obyYmKG89by5zbGljZSgwLG8ubGVuZ3RoLTEpKSx0K28pOiIuIn1mdW5jdGlvbiBsKGUsbj0hMSl7cmV0dXJuIShufHxlJiYhZS5zdGFydHNXaXRoKCIvIikmJiFlLm1hdGNoKC9eW0EtWl06LykmJiFlLnN0YXJ0c1dpdGgoIi4iKSYmIWUubWF0Y2goL15bYS16QS1aXShbYS16QS1aMC05LlwtK10pKjpcL1wvLykpJiZ2b2lkIDAhPT1lJiYhZS5pbmNsdWRlcygibm9kZV9tb2R1bGVzLyIpfWZ1bmN0aW9uIGQoZSl7Y29uc3Qgbj0vXlxzKlstXXs0LH0kLyx0PS9hdCAoPzphc3luYyApPyg/OiguKz8pXHMrXCgpPyg/OiguKyk6KFxkKyk6KFxkKyk/fChbXildKykpXCk/LztyZXR1cm4gbz0+e2NvbnN0IHI9by5tYXRjaCh0KTtpZihyKXtsZXQgbix0LG8saSxjO2lmKHJbMV0pe289clsxXTtsZXQgZT1vLmxhc3RJbmRleE9mKCIuIik7aWYoIi4iPT09b1tlLTFdJiZlLS0sZT4wKXtuPW8uc2xpY2UoMCxlKSx0PW8uc2xpY2UoZSsxKTtjb25zdCByPW4uaW5kZXhPZigiLk1vZHVsZSIpO3I+MCYmKG89by5zbGljZShyKzEpLG49bi5zbGljZSgwLHIpKX1pPXZvaWQgMH10JiYoaT1uLGM9dCksIjxhbm9ueW1vdXM+Ij09PXQmJihjPXZvaWQgMCxvPXZvaWQgMCksdm9pZCAwPT09byYmKGM9Y3x8cyxvPWk/YCR7aX0uJHtjfWA6Yyk7bGV0IGE9clsyXSYmclsyXS5zdGFydHNXaXRoKCJmaWxlOi8vIik/clsyXS5zbGljZSg3KTpyWzJdO2NvbnN0IHU9Im5hdGl2ZSI9PT1yWzVdO3JldHVybiBhJiZhLm1hdGNoKC9cL1tBLVpdOi8pJiYoYT1hLnNsaWNlKDEpKSxhfHwhcls1XXx8dXx8KGE9cls1XSkse2ZpbGVuYW1lOmEsbW9kdWxlOmU/ZShhKTp2b2lkIDAsZnVuY3Rpb246byxsaW5lbm86cGFyc2VJbnQoclszXSwxMCl8fHZvaWQgMCxjb2xubzpwYXJzZUludChyWzRdLDEwKXx8dm9pZCAwLGluX2FwcDpsKGEsdSl9fWlmKG8ubWF0Y2gobikpcmV0dXJue2ZpbGVuYW1lOm99fX1mdW5jdGlvbiBwKGUpe3JldHVybiBlLnJlcGxhY2UoL15bQS1aXTovLCIiKS5yZXBsYWNlKC9cXC9nLCIvIil9Y29uc3QgZz1uLG09ZnVuY3Rpb24oLi4uZSl7Y29uc3Qgbj1lLnNvcnQoKChlLG4pPT5lWzBdLW5bMF0pKS5tYXAoKGU9PmVbMV0pKTtyZXR1cm4oZSx0PTAsbz0wKT0+e2NvbnN0IHI9W10sdT1lLnNwbGl0KCJcbiIpO2ZvcihsZXQgZT10O2U8dS5sZW5ndGg7ZSsrKXtjb25zdCB0PXVbZV07aWYodC5sZW5ndGg+MTAyNCljb250aW51ZTtjb25zdCBzPWMudGVzdCh0KT90LnJlcGxhY2UoYywiJDEiKTp0O2lmKCFzLm1hdGNoKC9cUypFcnJvcjogLykpe2Zvcihjb25zdCBlIG9mIG4pe2NvbnN0IG49ZShzKTtpZihuKXtyLnB1c2gobik7YnJlYWt9fWlmKHIubGVuZ3RoPj1pK28pYnJlYWt9fXJldHVybiBmdW5jdGlvbihlKXtpZighZS5sZW5ndGgpcmV0dXJuW107Y29uc3Qgbj1BcnJheS5mcm9tKGUpOy9zZW50cnlXcmFwcGVkLy50ZXN0KG5bbi5sZW5ndGgtMV0uZnVuY3Rpb258fCIiKSYmbi5wb3AoKTtuLnJldmVyc2UoKSxhLnRlc3QobltuLmxlbmd0aC0xXS5mdW5jdGlvbnx8IiIpJiYobi5wb3AoKSxhLnRlc3QobltuLmxlbmd0aC0xXS5mdW5jdGlvbnx8IiIpJiZuLnBvcCgpKTtyZXR1cm4gbi5zbGljZSgwLGkpLm1hcCgoZT0+KHsuLi5lLGZpbGVuYW1lOmUuZmlsZW5hbWV8fG5bbi5sZW5ndGgtMV0uZmlsZW5hbWUsZnVuY3Rpb246ZS5mdW5jdGlvbnx8c30pKSl9KHIuc2xpY2UobykpfX0oWzkwLGQoZnVuY3Rpb24oZT0ocHJvY2Vzcy5hcmd2WzFdP2YocHJvY2Vzcy5hcmd2WzFdKTpwcm9jZXNzLmN3ZCgpKSxuPSJcXCI9PT1yKXtjb25zdCB0PW4/cChlKTplO3JldHVybiBlPT57aWYoIWUpcmV0dXJuO2NvbnN0IHI9bj9wKGUpOmU7bGV0e2RpcjppLGJhc2U6cyxleHQ6Y309by5wYXJzZShyKTsiLmpzIiE9PWMmJiIubWpzIiE9PWMmJiIuY2pzIiE9PWN8fChzPXMuc2xpY2UoMCwtMSpjLmxlbmd0aCkpLGl8fChpPSIuIik7Y29uc3QgYT1pLmxhc3RJbmRleE9mKCIvbm9kZV9tb2R1bGVzIik7aWYoYT4tMSlyZXR1cm5gJHtpLnNsaWNlKGErMTQpLnJlcGxhY2UoL1wvL2csIi4iKX06JHtzfWA7aWYoaS5zdGFydHNXaXRoKHQpKXtsZXQgZT1pLnNsaWNlKHQubGVuZ3RoKzEpLnJlcGxhY2UoL1wvL2csIi4iKTtyZXR1cm4gZSYmKGUrPSI6IiksZSs9cyxlfXJldHVybiBzfX0oZy5iYXNlUGF0aCkpXSk7ZnVuY3Rpb24gYiguLi5lKXtnLmRlYnVnJiZjb25zb2xlLmxvZygiW0xvY2FsVmFyaWFibGVzIFdvcmtlcl0iLC4uLmUpfWFzeW5jIGZ1bmN0aW9uIHYoZSxuLHQsbyl7Y29uc3Qgcj1hd2FpdCBlLnBvc3QoIlJ1bnRpbWUuZ2V0UHJvcGVydGllcyIse29iamVjdElkOm4sb3duUHJvcGVydGllczohMH0pO29bdF09ci5yZXN1bHQuZmlsdGVyKChlPT4ibGVuZ3RoIiE9PWUubmFtZSYmIWlzTmFOKHBhcnNlSW50KGUubmFtZSwxMCkpKSkuc29ydCgoKGUsbik9PnBhcnNlSW50KGUubmFtZSwxMCktcGFyc2VJbnQobi5uYW1lLDEwKSkpLm1hcCgoZT0+ZS52YWx1ZT8udmFsdWUpKX1hc3luYyBmdW5jdGlvbiAkKGUsbix0LG8pe2NvbnN0IHI9YXdhaXQgZS5wb3N0KCJSdW50aW1lLmdldFByb3BlcnRpZXMiLHtvYmplY3RJZDpuLG93blByb3BlcnRpZXM6ITB9KTtvW3RdPXIucmVzdWx0Lm1hcCgoZT0+W2UubmFtZSxlLnZhbHVlPy52YWx1ZV0pKS5yZWR1Y2UoKChlLFtuLHRdKT0+KGVbbl09dCxlKSkse30pfWZ1bmN0aW9uIHcoZSxuKXtlLnZhbHVlJiYoInZhbHVlImluIGUudmFsdWU/dm9pZCAwPT09ZS52YWx1ZS52YWx1ZXx8bnVsbD09PWUudmFsdWUudmFsdWU/bltlLm5hbWVdPWA8JHtlLnZhbHVlLnZhbHVlfT5gOm5bZS5uYW1lXT1lLnZhbHVlLnZhbHVlOiJkZXNjcmlwdGlvbiJpbiBlLnZhbHVlJiYiZnVuY3Rpb24iIT09ZS52YWx1ZS50eXBlP25bZS5uYW1lXT1gPCR7ZS52YWx1ZS5kZXNjcmlwdGlvbn0+YDoidW5kZWZpbmVkIj09PWUudmFsdWUudHlwZSYmKG5bZS5uYW1lXT0iPHVuZGVmaW5lZD4iKSl9YXN5bmMgZnVuY3Rpb24geShlLG4pe2NvbnN0IHQ9YXdhaXQgZS5wb3N0KCJSdW50aW1lLmdldFByb3BlcnRpZXMiLHtvYmplY3RJZDpuLG93blByb3BlcnRpZXM6ITB9KSxvPXt9O2Zvcihjb25zdCBuIG9mIHQucmVzdWx0KWlmKG4/LnZhbHVlPy5vYmplY3RJZCYmIkFycmF5Ij09PW4/LnZhbHVlLmNsYXNzTmFtZSl7Y29uc3QgdD1uLnZhbHVlLm9iamVjdElkO2F3YWl0IHYoZSx0LG4ubmFtZSxvKX1lbHNlIGlmKG4/LnZhbHVlPy5vYmplY3RJZCYmIk9iamVjdCI9PT1uPy52YWx1ZT8uY2xhc3NOYW1lKXtjb25zdCB0PW4udmFsdWUub2JqZWN0SWQ7YXdhaXQgJChlLHQsbi5uYW1lLG8pfWVsc2Ugbj8udmFsdWUmJncobixvKTtyZXR1cm4gb31sZXQgaDsoYXN5bmMgZnVuY3Rpb24oKXtjb25zdCBuPW5ldyBlO24uY29ubmVjdFRvTWFpblRocmVhZCgpLGIoIkNvbm5lY3RlZCB0byBtYWluIHRocmVhZCIpO2xldCBvPSExO24ub24oIkRlYnVnZ2VyLnJlc3VtZWQiLCgoKT0+e289ITF9KSksbi5vbigiRGVidWdnZXIucGF1c2VkIiwoZT0+e289ITAsYXN5bmMgZnVuY3Rpb24oZSxuLHtyZWFzb246byxkYXRhOnIsY2FsbEZyYW1lczppfSl7aWYoImV4Y2VwdGlvbiIhPT1vJiYicHJvbWlzZVJlamVjdGlvbiIhPT1vKXJldHVybjtoPy4oKTtjb25zdCBzPWZ1bmN0aW9uKGUsbil7aWYodm9pZCAwIT09bilyZXR1cm4gZnVuY3Rpb24oZSl7aWYodm9pZCAwIT09ZSlyZXR1cm4gZS5zbGljZSgtMTApLnJlZHVjZSgoKGUsbik9PmAke2V9LCR7bi5mdW5jdGlvbn0sJHtuLmxpbmVub30sJHtuLmNvbG5vfWApLCIiKX0oZShuLDEpKX0obixyPy5kZXNjcmlwdGlvbik7aWYobnVsbD09cylyZXR1cm47Y29uc3QgYz1bXTtmb3IobGV0IG49MDtuPGkubGVuZ3RoO24rKyl7Y29uc3R7c2NvcGVDaGFpbjp0LGZ1bmN0aW9uTmFtZTpvLHRoaXM6cn09aVtuXSxzPXQuZmluZCgoZT0+ImxvY2FsIj09PWUudHlwZSkpLGE9Imdsb2JhbCIhPT1yLmNsYXNzTmFtZSYmci5jbGFzc05hbWU/YCR7ci5jbGFzc05hbWV9LiR7b31gOm87aWYodm9pZCAwPT09cz8ub2JqZWN0Lm9iamVjdElkKWNbbl09e2Z1bmN0aW9uOmF9O2Vsc2V7Y29uc3QgdD1hd2FpdCB5KGUscy5vYmplY3Qub2JqZWN0SWQpO2Nbbl09e2Z1bmN0aW9uOmEsdmFyczp0fX19dD8ucG9zdE1lc3NhZ2Uoe2V4Y2VwdGlvbkhhc2g6cyxmcmFtZXM6Y30pfShuLG0sZS5wYXJhbXMpLnRoZW4oKCgpPT5vP24ucG9zdCgiRGVidWdnZXIucmVzdW1lIik6UHJvbWlzZS5yZXNvbHZlKCkpLChlPT57fSkpfSkpLGF3YWl0IG4ucG9zdCgiRGVidWdnZXIuZW5hYmxlIik7Y29uc3Qgcj0hMSE9PWcuY2FwdHVyZUFsbEV4Y2VwdGlvbnM7aWYoYXdhaXQgbi5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOnI/ImFsbCI6InVuY2F1Z2h0In0pLHIpe2NvbnN0IGU9Zy5tYXhFeGNlcHRpb25zUGVyU2Vjb25kfHw1MDtoPWZ1bmN0aW9uKGUsbix0KXtsZXQgbz0wLHI9NSxpPTA7cmV0dXJuIHNldEludGVydmFsKCgoKT0+ezA9PT1pP28+ZSYmKHIqPTIsdChyKSxyPjg2NDAwJiYocj04NjQwMCksaT1yKTooaS09MSwwPT09aSYmbigpKSxvPTB9KSwxZTMpLnVucmVmKCksKCk9PntvKz0xfX0oZSwoYXN5bmMoKT0+e2IoIlJhdGUtbGltaXQgbGlmdGVkLiIpLGF3YWl0IG4ucG9zdCgiRGVidWdnZXIuc2V0UGF1c2VPbkV4Y2VwdGlvbnMiLHtzdGF0ZToiYWxsIn0pfSksKGFzeW5jIGU9PntiKGBSYXRlLWxpbWl0IGV4Y2VlZGVkLiBEaXNhYmxpbmcgY2FwdHVyaW5nIG9mIGNhdWdodCBleGNlcHRpb25zIGZvciAke2V9IHNlY29uZHMuYCksYXdhaXQgbi5wb3N0KCJEZWJ1Z2dlci5zZXRQYXVzZU9uRXhjZXB0aW9ucyIse3N0YXRlOiJ1bmNhdWdodCJ9KX0pKX19KSgpLmNhdGNoKChlPT57YigiRmFpbGVkIHRvIHN0YXJ0IGRlYnVnZ2VyIixlKX0pKSxzZXRJbnRlcnZhbCgoKCk9Pnt9KSwxZTQpOw==';

function log$1(...args) {
  logger.log('[LocalVariables]', ...args);
}

/**
 * Adds local variables to exception frames
 */
const localVariablesAsyncIntegration = defineIntegration(((
  integrationOptions = {},
) => {
  const cachedFrames = new LRUMap(20);

  function addLocalVariablesToException(exception) {
    const hash = hashFrames(_optionalChain$b([exception, 'optionalAccess', _ => _.stacktrace, 'optionalAccess', _2 => _2.frames]));

    if (hash === undefined) {
      return;
    }

    // Check if we have local variables for an exception that matches the hash
    // remove is identical to get but also removes the entry from the cache
    const cachedFrame = cachedFrames.remove(hash);

    if (cachedFrame === undefined) {
      return;
    }

    // Filter out frames where the function name is `new Promise` since these are in the error.stack frames
    // but do not appear in the debugger call frames
    const frames = (_optionalChain$b([exception, 'access', _3 => _3.stacktrace, 'optionalAccess', _4 => _4.frames]) || []).filter(frame => frame.function !== 'new Promise');

    for (let i = 0; i < frames.length; i++) {
      // Sentry frames are in reverse order
      const frameIndex = frames.length - i - 1;

      // Drop out if we run out of frames to match up
      if (!frames[frameIndex] || !cachedFrame[i]) {
        break;
      }

      if (
        // We need to have vars to add
        cachedFrame[i].vars === undefined ||
        // We're not interested in frames that are not in_app because the vars are not relevant
        frames[frameIndex].in_app === false ||
        // The function names need to match
        !functionNamesMatch(frames[frameIndex].function, cachedFrame[i].function)
      ) {
        continue;
      }

      frames[frameIndex].vars = cachedFrame[i].vars;
    }
  }

  function addLocalVariablesToEvent(event) {
    for (const exception of _optionalChain$b([event, 'access', _5 => _5.exception, 'optionalAccess', _6 => _6.values]) || []) {
      addLocalVariablesToException(exception);
    }

    return event;
  }

  async function startInspector() {
    // We load inspector dynamically because on some platforms Node is built without inspector support
    const inspector = await import('inspector');
    if (!inspector.url()) {
      inspector.open(0);
    }
  }

  function startWorker(options) {
    const worker = new Worker(new URL(`data:application/javascript;base64,${base64WorkerScript$1}`), {
      workerData: options,
      // We don't want any Node args to be passed to the worker
      execArgv: [],
    });

    process.on('exit', () => {
      // eslint-disable-next-line @typescript-eslint/no-floating-promises
      worker.terminate();
    });

    worker.on('message', ({ exceptionHash, frames }) => {
      cachedFrames.set(exceptionHash, frames);
    });

    worker.once('error', (err) => {
      log$1('Worker error', err);
    });

    worker.once('exit', (code) => {
      log$1('Worker exit', code);
    });

    // Ensure this thread can't block app exit
    worker.unref();
  }

  return {
    name: 'LocalVariablesAsync',
    setup(client) {
      const clientOptions = client.getOptions();

      if (!clientOptions.includeLocalVariables) {
        return;
      }

      const options = {
        ...integrationOptions,
        debug: logger.isEnabled(),
      };

      startInspector().then(
        () => {
          try {
            startWorker(options);
          } catch (e) {
            logger.error('Failed to start worker', e);
          }
        },
        e => {
          logger.error('Failed to start inspector', e);
        },
      );
    },
    processEvent(event) {
      return addLocalVariablesToEvent(event);
    },
  };
}) );

function _optionalChain$a(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
/** Creates a container for callbacks to be called sequentially */
function createCallbackList(complete) {
  // A collection of callbacks to be executed last to first
  let callbacks = [];

  let completedCalled = false;
  function checkedComplete(result) {
    callbacks = [];
    if (completedCalled) {
      return;
    }
    completedCalled = true;
    complete(result);
  }

  // complete should be called last
  callbacks.push(checkedComplete);

  function add(fn) {
    callbacks.push(fn);
  }

  function next(result) {
    const popped = callbacks.pop() || checkedComplete;

    try {
      popped(result);
    } catch (_) {
      // If there is an error, we still want to call the complete callback
      checkedComplete(result);
    }
  }

  return { add, next };
}

/**
 * Promise API is available as `Experimental` and in Node 19 only.
 *
 * Callback-based API is `Stable` since v14 and `Experimental` since v8.
 * Because of that, we are creating our own `AsyncSession` class.
 *
 * https://nodejs.org/docs/latest-v19.x/api/inspector.html#promises-api
 * https://nodejs.org/docs/latest-v14.x/api/inspector.html
 */
class AsyncSession  {

  /** Throws if inspector API is not available */
   constructor() {
    this._session = new Session();
  }

  /** @inheritdoc */
   configureAndConnect(onPause, captureAll) {
    this._session.connect();

    this._session.on('Debugger.paused', event => {
      onPause(event, () => {
        // After the pause work is complete, resume execution or the exception context memory is leaked
        this._session.post('Debugger.resume');
      });
    });

    this._session.post('Debugger.enable');
    this._session.post('Debugger.setPauseOnExceptions', { state: captureAll ? 'all' : 'uncaught' });
  }

   setPauseOnExceptions(captureAll) {
    this._session.post('Debugger.setPauseOnExceptions', { state: captureAll ? 'all' : 'uncaught' });
  }

  /** @inheritdoc */
   getLocalVariables(objectId, complete) {
    this._getProperties(objectId, props => {
      const { add, next } = createCallbackList(complete);

      for (const prop of props) {
        if (_optionalChain$a([prop, 'optionalAccess', _2 => _2.value, 'optionalAccess', _3 => _3.objectId]) && _optionalChain$a([prop, 'optionalAccess', _4 => _4.value, 'access', _5 => _5.className]) === 'Array') {
          const id = prop.value.objectId;
          add(vars => this._unrollArray(id, prop.name, vars, next));
        } else if (_optionalChain$a([prop, 'optionalAccess', _6 => _6.value, 'optionalAccess', _7 => _7.objectId]) && _optionalChain$a([prop, 'optionalAccess', _8 => _8.value, 'optionalAccess', _9 => _9.className]) === 'Object') {
          const id = prop.value.objectId;
          add(vars => this._unrollObject(id, prop.name, vars, next));
        } else if (_optionalChain$a([prop, 'optionalAccess', _10 => _10.value])) {
          add(vars => this._unrollOther(prop, vars, next));
        }
      }

      next({});
    });
  }

  /**
   * Gets all the PropertyDescriptors of an object
   */
   _getProperties(objectId, next) {
    this._session.post(
      'Runtime.getProperties',
      {
        objectId,
        ownProperties: true,
      },
      (err, params) => {
        if (err) {
          next([]);
        } else {
          next(params.result);
        }
      },
    );
  }

  /**
   * Unrolls an array property
   */
   _unrollArray(objectId, name, vars, next) {
    this._getProperties(objectId, props => {
      vars[name] = props
        .filter(v => v.name !== 'length' && !isNaN(parseInt(v.name, 10)))
        .sort((a, b) => parseInt(a.name, 10) - parseInt(b.name, 10))
        .map(v => _optionalChain$a([v, 'optionalAccess', _11 => _11.value, 'optionalAccess', _12 => _12.value]));

      next(vars);
    });
  }

  /**
   * Unrolls an object property
   */
   _unrollObject(objectId, name, vars, next) {
    this._getProperties(objectId, props => {
      vars[name] = props
        .map(v => [v.name, _optionalChain$a([v, 'optionalAccess', _13 => _13.value, 'optionalAccess', _14 => _14.value])])
        .reduce((obj, [key, val]) => {
          obj[key] = val;
          return obj;
        }, {} );

      next(vars);
    });
  }

  /**
   * Unrolls other properties
   */
   _unrollOther(prop, vars, next) {
    if (prop.value) {
      if ('value' in prop.value) {
        if (prop.value.value === undefined || prop.value.value === null) {
          vars[prop.name] = `<${prop.value.value}>`;
        } else {
          vars[prop.name] = prop.value.value;
        }
      } else if ('description' in prop.value && prop.value.type !== 'function') {
        vars[prop.name] = `<${prop.value.description}>`;
      } else if (prop.value.type === 'undefined') {
        vars[prop.name] = '<undefined>';
      }
    }

    next(vars);
  }
}

/**
 * When using Vercel pkg, the inspector module is not available.
 * https://github.com/getsentry/sentry-javascript/issues/6769
 */
function tryNewAsyncSession() {
  try {
    return new AsyncSession();
  } catch (e) {
    return undefined;
  }
}

const INTEGRATION_NAME$5 = 'LocalVariables';

/**
 * Adds local variables to exception frames
 */
const _localVariablesSyncIntegration = ((
  options = {},
  session = tryNewAsyncSession(),
) => {
  const cachedFrames = new LRUMap(20);
  let rateLimiter;
  let shouldProcessEvent = false;

  function handlePaused(
    stackParser,
    { params: { reason, data, callFrames } },
    complete,
  ) {
    if (reason !== 'exception' && reason !== 'promiseRejection') {
      complete();
      return;
    }

    _optionalChain$a([rateLimiter, 'optionalCall', _15 => _15()]);

    // data.description contains the original error.stack
    const exceptionHash = hashFromStack(stackParser, _optionalChain$a([data, 'optionalAccess', _16 => _16.description]));

    if (exceptionHash == undefined) {
      complete();
      return;
    }

    const { add, next } = createCallbackList(frames => {
      cachedFrames.set(exceptionHash, frames);
      complete();
    });

    // Because we're queuing up and making all these calls synchronously, we can potentially overflow the stack
    // For this reason we only attempt to get local variables for the first 5 frames
    for (let i = 0; i < Math.min(callFrames.length, 5); i++) {
      const { scopeChain, functionName, this: obj } = callFrames[i];

      const localScope = scopeChain.find(scope => scope.type === 'local');

      // obj.className is undefined in ESM modules
      const fn = obj.className === 'global' || !obj.className ? functionName : `${obj.className}.${functionName}`;

      if (_optionalChain$a([localScope, 'optionalAccess', _17 => _17.object, 'access', _18 => _18.objectId]) === undefined) {
        add(frames => {
          frames[i] = { function: fn };
          next(frames);
        });
      } else {
        const id = localScope.object.objectId;
        add(frames =>
          _optionalChain$a([session, 'optionalAccess', _19 => _19.getLocalVariables, 'call', _20 => _20(id, vars => {
            frames[i] = { function: fn, vars };
            next(frames);
          })]),
        );
      }
    }

    next([]);
  }

  function addLocalVariablesToException(exception) {
    const hash = hashFrames(_optionalChain$a([exception, 'optionalAccess', _21 => _21.stacktrace, 'optionalAccess', _22 => _22.frames]));

    if (hash === undefined) {
      return;
    }

    // Check if we have local variables for an exception that matches the hash
    // remove is identical to get but also removes the entry from the cache
    const cachedFrame = cachedFrames.remove(hash);

    if (cachedFrame === undefined) {
      return;
    }

    // Filter out frames where the function name is `new Promise` since these are in the error.stack frames
    // but do not appear in the debugger call frames
    const frames = (_optionalChain$a([exception, 'access', _23 => _23.stacktrace, 'optionalAccess', _24 => _24.frames]) || []).filter(frame => frame.function !== 'new Promise');

    for (let i = 0; i < frames.length; i++) {
      // Sentry frames are in reverse order
      const frameIndex = frames.length - i - 1;

      // Drop out if we run out of frames to match up
      if (!frames[frameIndex] || !cachedFrame[i]) {
        break;
      }

      if (
        // We need to have vars to add
        cachedFrame[i].vars === undefined ||
        // We're not interested in frames that are not in_app because the vars are not relevant
        frames[frameIndex].in_app === false ||
        // The function names need to match
        !functionNamesMatch(frames[frameIndex].function, cachedFrame[i].function)
      ) {
        continue;
      }

      frames[frameIndex].vars = cachedFrame[i].vars;
    }
  }

  function addLocalVariablesToEvent(event) {
    for (const exception of _optionalChain$a([event, 'optionalAccess', _25 => _25.exception, 'optionalAccess', _26 => _26.values]) || []) {
      addLocalVariablesToException(exception);
    }

    return event;
  }

  return {
    name: INTEGRATION_NAME$5,
    setupOnce() {
      const client = getClient$1();
      const clientOptions = _optionalChain$a([client, 'optionalAccess', _27 => _27.getOptions, 'call', _28 => _28()]);

      if (session && _optionalChain$a([clientOptions, 'optionalAccess', _29 => _29.includeLocalVariables])) {
        // Only setup this integration if the Node version is >= v18
        // https://github.com/getsentry/sentry-javascript/issues/7697
        const unsupportedNodeVersion = NODE_MAJOR < 18;

        if (unsupportedNodeVersion) {
          logger.log('The `LocalVariables` integration is only supported on Node >= v18.');
          return;
        }

        const captureAll = options.captureAllExceptions !== false;

        session.configureAndConnect(
          (ev, complete) =>
            handlePaused(clientOptions.stackParser, ev , complete),
          captureAll,
        );

        if (captureAll) {
          const max = options.maxExceptionsPerSecond || 50;

          rateLimiter = createRateLimiter(
            max,
            () => {
              logger.log('Local variables rate-limit lifted.');
              _optionalChain$a([session, 'optionalAccess', _30 => _30.setPauseOnExceptions, 'call', _31 => _31(true)]);
            },
            seconds => {
              logger.log(
                `Local variables rate-limit exceeded. Disabling capturing of caught exceptions for ${seconds} seconds.`,
              );
              _optionalChain$a([session, 'optionalAccess', _32 => _32.setPauseOnExceptions, 'call', _33 => _33(false)]);
            },
          );
        }

        shouldProcessEvent = true;
      }
    },
    processEvent(event) {
      if (shouldProcessEvent) {
        return addLocalVariablesToEvent(event);
      }

      return event;
    },
    // These are entirely for testing
    _getCachedFramesCount() {
      return cachedFrames.size;
    },
    _getFirstCachedFrame() {
      return cachedFrames.values()[0];
    },
  };
}) ;

/**
 * Adds local variables to exception frames.
 */
const localVariablesSyncIntegration = defineIntegration(_localVariablesSyncIntegration);

const localVariablesIntegration = (options = {}) => {
  return NODE_VERSION.major < 19 ? localVariablesSyncIntegration(options) : localVariablesAsyncIntegration(options);
};

let moduleCache;

const INTEGRATION_NAME$4 = 'Modules';

const _modulesIntegration = (() => {
  return {
    name: INTEGRATION_NAME$4,
    processEvent(event) {
      event.modules = {
        ...event.modules,
        ..._getModules(),
      };

      return event;
    },
  };
}) ;

/**
 * Add node modules / packages to the event.
 */
const modulesIntegration = defineIntegration(_modulesIntegration);

/** Extract information about paths */
function getPaths() {
  try {
    return require.cache ? Object.keys(require.cache ) : [];
  } catch (e) {
    return [];
  }
}

/** Extract information about package.json modules */
function collectModules()

 {
  const mainPaths = (require.main && require.main.paths) || [];
  const paths = getPaths();
  const infos

 = {};
  const seen

 = {};

  paths.forEach(path => {
    let dir = path;

    /** Traverse directories upward in the search of package.json file */
    const updir = () => {
      const orig = dir;
      dir = dirname(orig);

      if (!dir || orig === dir || seen[orig]) {
        return undefined;
      }
      if (mainPaths.indexOf(dir) < 0) {
        return updir();
      }

      const pkgfile = join(orig, 'package.json');
      seen[orig] = true;

      if (!existsSync(pkgfile)) {
        return updir();
      }

      try {
        const info = JSON.parse(readFileSync(pkgfile, 'utf8'))

;
        infos[info.name] = info.version;
      } catch (_oO) {
        // no-empty
      }
    };

    updir();
  });

  return infos;
}

/** Fetches the list of modules and the versions loaded by the entry file for your node.js app. */
function _getModules() {
  if (!moduleCache) {
    moduleCache = collectModules();
  }
  return moduleCache;
}

const DEFAULT_SHUTDOWN_TIMEOUT = 2000;

/**
 * @hidden
 */
function logAndExitProcess(error) {
  consoleSandbox(() => {
    // eslint-disable-next-line no-console
    console.error(error);
  });

  const client = getClient$1();

  if (client === undefined) {
    DEBUG_BUILD && logger.warn('No NodeClient was defined, we are exiting the process now.');
    global.process.exit(1);
    return;
  }

  const options = client.getOptions();
  const timeout =
    (options && options.shutdownTimeout && options.shutdownTimeout > 0 && options.shutdownTimeout) ||
    DEFAULT_SHUTDOWN_TIMEOUT;
  client.close(timeout).then(
    (result) => {
      if (!result) {
        DEBUG_BUILD && logger.warn('We reached the timeout for emptying the request buffer, still exiting now!');
      }
      global.process.exit(1);
    },
    error => {
      DEBUG_BUILD && logger.error(error);
    },
  );
}

const INTEGRATION_NAME$3 = 'OnUncaughtException';

/**
 * Add a global exception handler.
 */
const onUncaughtExceptionIntegration = defineIntegration((options = {}) => {
  const optionsWithDefaults = {
    exitEvenIfOtherHandlersAreRegistered: false,
    ...options,
  };

  return {
    name: INTEGRATION_NAME$3,
    setup(client) {
      global.process.on('uncaughtException', makeErrorHandler(client, optionsWithDefaults));
    },
  };
});

/** Exported only for tests */
function makeErrorHandler(client, options) {
  const timeout = 2000;
  let caughtFirstError = false;
  let caughtSecondError = false;
  let calledFatalError = false;
  let firstError;

  const clientOptions = client.getOptions();

  return Object.assign(
    (error) => {
      let onFatalError = logAndExitProcess;

      if (options.onFatalError) {
        onFatalError = options.onFatalError;
      } else if (clientOptions.onFatalError) {
        onFatalError = clientOptions.onFatalError ;
      }

      // Attaching a listener to `uncaughtException` will prevent the node process from exiting. We generally do not
      // want to alter this behaviour so we check for other listeners that users may have attached themselves and adjust
      // exit behaviour of the SDK accordingly:
      // - If other listeners are attached, do not exit.
      // - If the only listener attached is ours, exit.
      const userProvidedListenersCount = (global.process.listeners('uncaughtException') ).filter(
        listener => {
          // There are 3 listeners we ignore:
          return (
            // as soon as we're using domains this listener is attached by node itself
            listener.name !== 'domainUncaughtExceptionClear' &&
            // the handler we register for tracing
            listener.tag !== 'sentry_tracingErrorCallback' &&
            // the handler we register in this integration
            (listener )._errorHandler !== true
          );
        },
      ).length;

      const processWouldExit = userProvidedListenersCount === 0;
      const shouldApplyFatalHandlingLogic = options.exitEvenIfOtherHandlersAreRegistered || processWouldExit;

      if (!caughtFirstError) {
        // this is the first uncaught error and the ultimate reason for shutting down
        // we want to do absolutely everything possible to ensure it gets captured
        // also we want to make sure we don't go recursion crazy if more errors happen after this one
        firstError = error;
        caughtFirstError = true;

        if (getClient$1() === client) {
          captureException(error, {
            originalException: error,
            captureContext: {
              level: 'fatal',
            },
            mechanism: {
              handled: false,
              type: 'onuncaughtexception',
            },
          });
        }

        if (!calledFatalError && shouldApplyFatalHandlingLogic) {
          calledFatalError = true;
          onFatalError(error);
        }
      } else {
        if (shouldApplyFatalHandlingLogic) {
          if (calledFatalError) {
            // we hit an error *after* calling onFatalError - pretty boned at this point, just shut it down
            DEBUG_BUILD &&
              logger.warn(
                'uncaught exception after calling fatal error shutdown callback - this is bad! forcing shutdown',
              );
            logAndExitProcess(error);
          } else if (!caughtSecondError) {
            // two cases for how we can hit this branch:
            //   - capturing of first error blew up and we just caught the exception from that
            //     - quit trying to capture, proceed with shutdown
            //   - a second independent error happened while waiting for first error to capture
            //     - want to avoid causing premature shutdown before first error capture finishes
            // it's hard to immediately tell case 1 from case 2 without doing some fancy/questionable domain stuff
            // so let's instead just delay a bit before we proceed with our action here
            // in case 1, we just wait a bit unnecessarily but ultimately do the same thing
            // in case 2, the delay hopefully made us wait long enough for the capture to finish
            // two potential nonideal outcomes:
            //   nonideal case 1: capturing fails fast, we sit around for a few seconds unnecessarily before proceeding correctly by calling onFatalError
            //   nonideal case 2: case 2 happens, 1st error is captured but slowly, timeout completes before capture and we treat second error as the sendErr of (nonexistent) failure from trying to capture first error
            // note that after hitting this branch, we might catch more errors where (caughtSecondError && !calledFatalError)
            //   we ignore them - they don't matter to us, we're just waiting for the second error timeout to finish
            caughtSecondError = true;
            setTimeout(() => {
              if (!calledFatalError) {
                // it was probably case 1, let's treat err as the sendErr and call onFatalError
                calledFatalError = true;
                onFatalError(firstError, error);
              }
            }, timeout); // capturing could take at least sendTimeout to fail, plus an arbitrary second for how long it takes to collect surrounding source etc
          }
        }
      }
    },
    { _errorHandler: true },
  );
}

const INTEGRATION_NAME$2 = 'OnUnhandledRejection';

const _onUnhandledRejectionIntegration = ((options = {}) => {
  const mode = options.mode || 'warn';

  return {
    name: INTEGRATION_NAME$2,
    setup(client) {
      global.process.on('unhandledRejection', makeUnhandledPromiseHandler(client, { mode }));
    },
  };
}) ;

/**
 * Add a global promise rejection handler.
 */
const onUnhandledRejectionIntegration = defineIntegration(_onUnhandledRejectionIntegration);

/**
 * Send an exception with reason
 * @param reason string
 * @param promise promise
 *
 * Exported only for tests.
 */
function makeUnhandledPromiseHandler(
  client,
  options,
) {
  return function sendUnhandledPromise(reason, promise) {
    if (getClient$1() !== client) {
      return;
    }

    captureException(reason, {
      originalException: promise,
      captureContext: {
        extra: { unhandledPromiseRejection: true },
      },
      mechanism: {
        handled: false,
        type: 'onunhandledrejection',
      },
    });

    handleRejection(reason, options);
  };
}

/**
 * Handler for `mode` option

 */
function handleRejection(
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  reason,
  options,
) {
  // https://github.com/nodejs/node/blob/7cf6f9e964aa00772965391c23acda6d71972a9a/lib/internal/process/promises.js#L234-L240
  const rejectionWarning =
    'This error originated either by ' +
    'throwing inside of an async function without a catch block, ' +
    'or by rejecting a promise which was not handled with .catch().' +
    ' The promise rejected with the reason:';

  /* eslint-disable no-console */
  if (options.mode === 'warn') {
    consoleSandbox(() => {
      console.warn(rejectionWarning);
      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
      console.error(reason && reason.stack ? reason.stack : reason);
    });
  } else if (options.mode === 'strict') {
    consoleSandbox(() => {
      console.warn(rejectionWarning);
    });
    logAndExitProcess(reason);
  }
  /* eslint-enable no-console */
}

function _optionalChain$9(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
// This string is a placeholder that gets overwritten with the worker code.
const base64WorkerScript = 'LyohIEBzZW50cnkvbm9kZSA4LjAuMCAoYzMzNmIxMSkgfCBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0ICovCmltcG9ydHtTZXNzaW9uIGFzIHR9ZnJvbSJpbnNwZWN0b3IiO2ltcG9ydHtwYXJlbnRQb3J0IGFzIGUsd29ya2VyRGF0YSBhcyBufWZyb20id29ya2VyX3RocmVhZHMiO2ltcG9ydHtwb3NpeCBhcyByLHNlcCBhcyBvfWZyb20icGF0aCI7aW1wb3J0KmFzIHMgZnJvbSJub2RlOmh0dHAiO2ltcG9ydCphcyBpIGZyb20ibm9kZTpodHRwcyI7aW1wb3J0e1JlYWRhYmxlIGFzIGN9ZnJvbSJzdHJlYW0iO2ltcG9ydHtjcmVhdGVHemlwIGFzIHV9ZnJvbSJ6bGliIjtpbXBvcnQqYXMgYSBmcm9tIm5ldCI7aW1wb3J0KmFzIGYgZnJvbSJ0bHMiO2ltcG9ydCphcyBoIGZyb20iaHR0cCI7Y29uc3QgcD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO2Z1bmN0aW9uIGwodCxlKXtyZXR1cm4gcC5jYWxsKHQpPT09YFtvYmplY3QgJHtlfV1gfWZ1bmN0aW9uIGQodCl7cmV0dXJuIGwodCwiT2JqZWN0Iil9ZnVuY3Rpb24gbSh0KXtyZXR1cm4gQm9vbGVhbih0JiZ0LnRoZW4mJiJmdW5jdGlvbiI9PXR5cGVvZiB0LnRoZW4pfWZ1bmN0aW9uIGcodCxlKXt0cnl7cmV0dXJuIHQgaW5zdGFuY2VvZiBlfWNhdGNoKHQpe3JldHVybiExfX1jb25zdCB5PWdsb2JhbFRoaXM7ZnVuY3Rpb24gYih0LGUsbil7Y29uc3Qgcj1ufHx5LG89ci5fX1NFTlRSWV9fPXIuX19TRU5UUllfX3x8e307cmV0dXJuIG9bdF18fChvW3RdPWUoKSl9Y29uc3Qgdj15LF89ODA7ZnVuY3Rpb24gdyh0LGUpe2NvbnN0IG49dCxyPVtdO2xldCBvLHMsaSxjLHU7aWYoIW58fCFuLnRhZ05hbWUpcmV0dXJuIiI7aWYodi5IVE1MRWxlbWVudCYmbiBpbnN0YW5jZW9mIEhUTUxFbGVtZW50JiZuLmRhdGFzZXQpe2lmKG4uZGF0YXNldC5zZW50cnlDb21wb25lbnQpcmV0dXJuIG4uZGF0YXNldC5zZW50cnlDb21wb25lbnQ7aWYobi5kYXRhc2V0LnNlbnRyeUVsZW1lbnQpcmV0dXJuIG4uZGF0YXNldC5zZW50cnlFbGVtZW50fXIucHVzaChuLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7Y29uc3QgYT1lJiZlLmxlbmd0aD9lLmZpbHRlcigodD0+bi5nZXRBdHRyaWJ1dGUodCkpKS5tYXAoKHQ9Plt0LG4uZ2V0QXR0cmlidXRlKHQpXSkpOm51bGw7aWYoYSYmYS5sZW5ndGgpYS5mb3JFYWNoKCh0PT57ci5wdXNoKGBbJHt0WzBdfT0iJHt0WzFdfSJdYCl9KSk7ZWxzZSBpZihuLmlkJiZyLnB1c2goYCMke24uaWR9YCksbz1uLmNsYXNzTmFtZSxvJiZsKG8sIlN0cmluZyIpKWZvcihzPW8uc3BsaXQoL1xzKy8pLHU9MDt1PHMubGVuZ3RoO3UrKylyLnB1c2goYC4ke3NbdV19YCk7Y29uc3QgZj1bImFyaWEtbGFiZWwiLCJ0eXBlIiwibmFtZSIsInRpdGxlIiwiYWx0Il07Zm9yKHU9MDt1PGYubGVuZ3RoO3UrKylpPWZbdV0sYz1uLmdldEF0dHJpYnV0ZShpKSxjJiZyLnB1c2goYFske2l9PSIke2N9Il1gKTtyZXR1cm4gci5qb2luKCIiKX1jb25zdCBTPSJ1bmRlZmluZWQiPT10eXBlb2YgX19TRU5UUllfREVCVUdfX3x8X19TRU5UUllfREVCVUdfXywkPVsiZGVidWciLCJpbmZvIiwid2FybiIsImVycm9yIiwibG9nIiwiYXNzZXJ0IiwidHJhY2UiXSxFPXt9O2Z1bmN0aW9uIHgodCl7aWYoISgiY29uc29sZSJpbiB5KSlyZXR1cm4gdCgpO2NvbnN0IGU9eS5jb25zb2xlLG49e30scj1PYmplY3Qua2V5cyhFKTtyLmZvckVhY2goKHQ9Pntjb25zdCByPUVbdF07blt0XT1lW3RdLGVbdF09cn0pKTt0cnl7cmV0dXJuIHQoKX1maW5hbGx5e3IuZm9yRWFjaCgodD0+e2VbdF09blt0XX0pKX19Y29uc3QgTj1mdW5jdGlvbigpe2xldCB0PSExO2NvbnN0IGU9e2VuYWJsZTooKT0+e3Q9ITB9LGRpc2FibGU6KCk9Pnt0PSExfSxpc0VuYWJsZWQ6KCk9PnR9O3JldHVybiBTPyQuZm9yRWFjaCgobj0+e2Vbbl09KC4uLmUpPT57dCYmeCgoKCk9Pnt5LmNvbnNvbGVbbl0oYFNlbnRyeSBMb2dnZXIgWyR7bn1dOmAsLi4uZSl9KSl9fSkpOiQuZm9yRWFjaCgodD0+e2VbdF09KCk9Pnt9fSkpLGV9KCk7ZnVuY3Rpb24gayh0LGU9ITEpe2NvbnN0e2hvc3Q6bixwYXRoOnIscGFzczpvLHBvcnQ6cyxwcm9qZWN0SWQ6aSxwcm90b2NvbDpjLHB1YmxpY0tleTp1fT10O3JldHVybmAke2N9Oi8vJHt1fSR7ZSYmbz9gOiR7b31gOiIifUAke259JHtzP2A6JHtzfWA6IiJ9LyR7cj9gJHtyfS9gOnJ9JHtpfWB9Y2xhc3MgQyBleHRlbmRzIEVycm9ye2NvbnN0cnVjdG9yKHQsZT0id2FybiIpe3N1cGVyKHQpLHRoaXMubWVzc2FnZT10LHRoaXMubmFtZT1uZXcudGFyZ2V0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lLE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLG5ldy50YXJnZXQucHJvdG90eXBlKSx0aGlzLmxvZ0xldmVsPWV9fWZ1bmN0aW9uIEQodCl7aWYoZnVuY3Rpb24odCl7c3dpdGNoKHAuY2FsbCh0KSl7Y2FzZSJbb2JqZWN0IEVycm9yXSI6Y2FzZSJbb2JqZWN0IEV4Y2VwdGlvbl0iOmNhc2UiW29iamVjdCBET01FeGNlcHRpb25dIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiBnKHQsRXJyb3IpfX0odCkpcmV0dXJue21lc3NhZ2U6dC5tZXNzYWdlLG5hbWU6dC5uYW1lLHN0YWNrOnQuc3RhY2ssLi4uTyh0KX07aWYoZT10LCJ1bmRlZmluZWQiIT10eXBlb2YgRXZlbnQmJmcoZSxFdmVudCkpe2NvbnN0IGU9e3R5cGU6dC50eXBlLHRhcmdldDpUKHQudGFyZ2V0KSxjdXJyZW50VGFyZ2V0OlQodC5jdXJyZW50VGFyZ2V0KSwuLi5PKHQpfTtyZXR1cm4idW5kZWZpbmVkIiE9dHlwZW9mIEN1c3RvbUV2ZW50JiZnKHQsQ3VzdG9tRXZlbnQpJiYoZS5kZXRhaWw9dC5kZXRhaWwpLGV9cmV0dXJuIHQ7dmFyIGV9ZnVuY3Rpb24gVCh0KXt0cnl7cmV0dXJuIGU9dCwidW5kZWZpbmVkIiE9dHlwZW9mIEVsZW1lbnQmJmcoZSxFbGVtZW50KT9mdW5jdGlvbih0LGU9e30pe2lmKCF0KXJldHVybiI8dW5rbm93bj4iO3RyeXtsZXQgbj10O2NvbnN0IHI9NSxvPVtdO2xldCBzPTAsaT0wO2NvbnN0IGM9IiA+ICIsdT1jLmxlbmd0aDtsZXQgYTtjb25zdCBmPUFycmF5LmlzQXJyYXkoZSk/ZTplLmtleUF0dHJzLGg9IUFycmF5LmlzQXJyYXkoZSkmJmUubWF4U3RyaW5nTGVuZ3RofHxfO2Zvcig7biYmcysrPHImJihhPXcobixmKSwhKCJodG1sIj09PWF8fHM+MSYmaStvLmxlbmd0aCp1K2EubGVuZ3RoPj1oKSk7KW8ucHVzaChhKSxpKz1hLmxlbmd0aCxuPW4ucGFyZW50Tm9kZTtyZXR1cm4gby5yZXZlcnNlKCkuam9pbihjKX1jYXRjaCh0KXtyZXR1cm4iPHVua25vd24+In19KHQpOk9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX1jYXRjaCh0KXtyZXR1cm4iPHVua25vd24+In12YXIgZX1mdW5jdGlvbiBPKHQpe2lmKCJvYmplY3QiPT10eXBlb2YgdCYmbnVsbCE9PXQpe2NvbnN0IGU9e307Zm9yKGNvbnN0IG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKGVbbl09dFtuXSk7cmV0dXJuIGV9cmV0dXJue319ZnVuY3Rpb24gaih0KXtyZXR1cm4gUih0LG5ldyBNYXApfWZ1bmN0aW9uIFIodCxlKXtpZihmdW5jdGlvbih0KXtpZighZCh0KSlyZXR1cm4hMTt0cnl7Y29uc3QgZT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IubmFtZTtyZXR1cm4hZXx8Ik9iamVjdCI9PT1lfWNhdGNoKHQpe3JldHVybiEwfX0odCkpe2NvbnN0IG49ZS5nZXQodCk7aWYodm9pZCAwIT09bilyZXR1cm4gbjtjb25zdCByPXt9O2Uuc2V0KHQscik7Zm9yKGNvbnN0IG4gb2YgT2JqZWN0LmtleXModCkpdm9pZCAwIT09dFtuXSYmKHJbbl09Uih0W25dLGUpKTtyZXR1cm4gcn1pZihBcnJheS5pc0FycmF5KHQpKXtjb25zdCBuPWUuZ2V0KHQpO2lmKHZvaWQgMCE9PW4pcmV0dXJuIG47Y29uc3Qgcj1bXTtyZXR1cm4gZS5zZXQodCxyKSx0LmZvckVhY2goKHQ9PntyLnB1c2goUih0LGUpKX0pKSxyfXJldHVybiB0fWNvbnN0IEE9NTAsST0iPyIsUD0vY2FwdHVyZU1lc3NhZ2V8Y2FwdHVyZUV4Y2VwdGlvbi87Y29uc3QgVT0iPGFub255bW91cz4iO2Z1bmN0aW9uIE0oKXtjb25zdCB0PXksZT10LmNyeXB0b3x8dC5tc0NyeXB0bztsZXQgbj0oKT0+MTYqTWF0aC5yYW5kb20oKTt0cnl7aWYoZSYmZS5yYW5kb21VVUlEKXJldHVybiBlLnJhbmRvbVVVSUQoKS5yZXBsYWNlKC8tL2csIiIpO2UmJmUuZ2V0UmFuZG9tVmFsdWVzJiYobj0oKT0+e2NvbnN0IHQ9bmV3IFVpbnQ4QXJyYXkoMSk7cmV0dXJuIGUuZ2V0UmFuZG9tVmFsdWVzKHQpLHRbMF19KX1jYXRjaCh0KXt9cmV0dXJuKFsxZTddKzFlMys0ZTMrOGUzKzFlMTEpLnJlcGxhY2UoL1swMThdL2csKHQ9Pih0XigxNSZuKCkpPj50LzQpLnRvU3RyaW5nKDE2KSkpfWZ1bmN0aW9uIEwodCxlPTEwMCxuPTEvMCl7dHJ5e3JldHVybiBCKCIiLHQsZSxuKX1jYXRjaCh0KXtyZXR1cm57RVJST1I6YCoqbm9uLXNlcmlhbGl6YWJsZSoqICgke3R9KWB9fX1mdW5jdGlvbiBCKHQsZSxuPTEvMCxyPTEvMCxvPWZ1bmN0aW9uKCl7Y29uc3QgdD0iZnVuY3Rpb24iPT10eXBlb2YgV2Vha1NldCxlPXQ/bmV3IFdlYWtTZXQ6W107cmV0dXJuW2Z1bmN0aW9uKG4pe2lmKHQpcmV0dXJuISFlLmhhcyhuKXx8KGUuYWRkKG4pLCExKTtmb3IobGV0IHQ9MDt0PGUubGVuZ3RoO3QrKylpZihlW3RdPT09bilyZXR1cm4hMDtyZXR1cm4gZS5wdXNoKG4pLCExfSxmdW5jdGlvbihuKXtpZih0KWUuZGVsZXRlKG4pO2Vsc2UgZm9yKGxldCB0PTA7dDxlLmxlbmd0aDt0KyspaWYoZVt0XT09PW4pe2Uuc3BsaWNlKHQsMSk7YnJlYWt9fV19KCkpe2NvbnN0W3MsaV09bztpZihudWxsPT1lfHxbIm51bWJlciIsImJvb2xlYW4iLCJzdHJpbmciXS5pbmNsdWRlcyh0eXBlb2YgZSkmJiFOdW1iZXIuaXNOYU4oZSkpcmV0dXJuIGU7Y29uc3QgYz1mdW5jdGlvbih0LGUpe3RyeXtpZigiZG9tYWluIj09PXQmJmUmJiJvYmplY3QiPT10eXBlb2YgZSYmZS50KXJldHVybiJbRG9tYWluXSI7aWYoImRvbWFpbkVtaXR0ZXIiPT09dClyZXR1cm4iW0RvbWFpbkVtaXR0ZXJdIjtpZigidW5kZWZpbmVkIiE9dHlwZW9mIGdsb2JhbCYmZT09PWdsb2JhbClyZXR1cm4iW0dsb2JhbF0iO2lmKCJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93JiZlPT09d2luZG93KXJldHVybiJbV2luZG93XSI7aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBkb2N1bWVudCYmZT09PWRvY3VtZW50KXJldHVybiJbRG9jdW1lbnRdIjtpZigib2JqZWN0Ij09dHlwZW9mKG49ZSkmJm51bGwhPT1uJiYobi5fX2lzVnVlfHxuLm8pKXJldHVybiJbVnVlVmlld01vZGVsXSI7aWYoZnVuY3Rpb24odCl7cmV0dXJuIGQodCkmJiJuYXRpdmVFdmVudCJpbiB0JiYicHJldmVudERlZmF1bHQiaW4gdCYmInN0b3BQcm9wYWdhdGlvbiJpbiB0fShlKSlyZXR1cm4iW1N5bnRoZXRpY0V2ZW50XSI7aWYoIm51bWJlciI9PXR5cGVvZiBlJiZlIT1lKXJldHVybiJbTmFOXSI7aWYoImZ1bmN0aW9uIj09dHlwZW9mIGUpcmV0dXJuYFtGdW5jdGlvbjogJHtmdW5jdGlvbih0KXt0cnl7cmV0dXJuIHQmJiJmdW5jdGlvbiI9PXR5cGVvZiB0JiZ0Lm5hbWV8fFV9Y2F0Y2godCl7cmV0dXJuIFV9fShlKX1dYDtpZigic3ltYm9sIj09dHlwZW9mIGUpcmV0dXJuYFske1N0cmluZyhlKX1dYDtpZigiYmlnaW50Ij09dHlwZW9mIGUpcmV0dXJuYFtCaWdJbnQ6ICR7U3RyaW5nKGUpfV1gO2NvbnN0IHI9ZnVuY3Rpb24odCl7Y29uc3QgZT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodCk7cmV0dXJuIGU/ZS5jb25zdHJ1Y3Rvci5uYW1lOiJudWxsIHByb3RvdHlwZSJ9KGUpO3JldHVybi9eSFRNTChcdyopRWxlbWVudCQvLnRlc3Qocik/YFtIVE1MRWxlbWVudDogJHtyfV1gOmBbb2JqZWN0ICR7cn1dYH1jYXRjaCh0KXtyZXR1cm5gKipub24tc2VyaWFsaXphYmxlKiogKCR7dH0pYH12YXIgbn0odCxlKTtpZighYy5zdGFydHNXaXRoKCJbb2JqZWN0ICIpKXJldHVybiBjO2lmKGUuX19zZW50cnlfc2tpcF9ub3JtYWxpemF0aW9uX18pcmV0dXJuIGU7Y29uc3QgdT0ibnVtYmVyIj09dHlwZW9mIGUuX19zZW50cnlfb3ZlcnJpZGVfbm9ybWFsaXphdGlvbl9kZXB0aF9fP2UuX19zZW50cnlfb3ZlcnJpZGVfbm9ybWFsaXphdGlvbl9kZXB0aF9fOm47aWYoMD09PXUpcmV0dXJuIGMucmVwbGFjZSgib2JqZWN0ICIsIiIpO2lmKHMoZSkpcmV0dXJuIltDaXJjdWxhciB+XSI7Y29uc3QgYT1lO2lmKGEmJiJmdW5jdGlvbiI9PXR5cGVvZiBhLnRvSlNPTil0cnl7cmV0dXJuIEIoIiIsYS50b0pTT04oKSx1LTEscixvKX1jYXRjaCh0KXt9Y29uc3QgZj1BcnJheS5pc0FycmF5KGUpP1tdOnt9O2xldCBoPTA7Y29uc3QgcD1EKGUpO2Zvcihjb25zdCB0IGluIHApe2lmKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocCx0KSljb250aW51ZTtpZihoPj1yKXtmW3RdPSJbTWF4UHJvcGVydGllcyB+XSI7YnJlYWt9Y29uc3QgZT1wW3RdO2ZbdF09Qih0LGUsdS0xLHIsbyksaCsrfXJldHVybiBpKGUpLGZ9ZnVuY3Rpb24gRyh0LGUpe2NvbnN0IG49ZS5yZXBsYWNlKC9cXC9nLCIvIikucmVwbGFjZSgvW3xcXHt9KClbXF1eJCsqPy5dL2csIlxcJCYiKTtsZXQgcj10O3RyeXtyPWRlY29kZVVSSSh0KX1jYXRjaCh0KXt9cmV0dXJuIHIucmVwbGFjZSgvXFwvZywiLyIpLnJlcGxhY2UoL3dlYnBhY2s6XC8/L2csIiIpLnJlcGxhY2UobmV3IFJlZ0V4cChgKGZpbGU6Ly8pPy8qJHtufS8qYCwiaWciKSwiYXBwOi8vLyIpfWNvbnN0IEo9L14oXFMrOlxcfFwvPykoW1xzXFNdKj8pKCg/OlwuezEsMn18W14vXFxdKz98KShcLlteLi9cXF0qfCkpKD86Wy9cXF0qKSQvO2Z1bmN0aW9uIHoodCl7Y29uc3QgZT1mdW5jdGlvbih0KXtjb25zdCBlPXQubGVuZ3RoPjEwMjQ/YDx0cnVuY2F0ZWQ+JHt0LnNsaWNlKC0xMDI0KX1gOnQsbj1KLmV4ZWMoZSk7cmV0dXJuIG4/bi5zbGljZSgxKTpbXX0odCksbj1lWzBdO2xldCByPWVbMV07cmV0dXJuIG58fHI/KHImJihyPXIuc2xpY2UoMCxyLmxlbmd0aC0xKSksbityKToiLiJ9dmFyIEg7ZnVuY3Rpb24gVyh0KXtyZXR1cm4gbmV3IFkoKGU9PntlKHQpfSkpfSFmdW5jdGlvbih0KXt0W3QuUEVORElORz0wXT0iUEVORElORyI7dFt0LlJFU09MVkVEPTFdPSJSRVNPTFZFRCI7dFt0LlJFSkVDVEVEPTJdPSJSRUpFQ1RFRCJ9KEh8fChIPXt9KSk7Y2xhc3MgWXtjb25zdHJ1Y3Rvcih0KXtZLnByb3RvdHlwZS5fX2luaXQuY2FsbCh0aGlzKSxZLnByb3RvdHlwZS5fX2luaXQyLmNhbGwodGhpcyksWS5wcm90b3R5cGUuX19pbml0My5jYWxsKHRoaXMpLFkucHJvdG90eXBlLl9faW5pdDQuY2FsbCh0aGlzKSx0aGlzLmk9SC5QRU5ESU5HLHRoaXMudT1bXTt0cnl7dCh0aGlzLmgsdGhpcy5wKX1jYXRjaCh0KXt0aGlzLnAodCl9fXRoZW4odCxlKXtyZXR1cm4gbmV3IFkoKChuLHIpPT57dGhpcy51LnB1c2goWyExLGU9PntpZih0KXRyeXtuKHQoZSkpfWNhdGNoKHQpe3IodCl9ZWxzZSBuKGUpfSx0PT57aWYoZSl0cnl7bihlKHQpKX1jYXRjaCh0KXtyKHQpfWVsc2Ugcih0KX1dKSx0aGlzLmwoKX0pKX1jYXRjaCh0KXtyZXR1cm4gdGhpcy50aGVuKCh0PT50KSx0KX1maW5hbGx5KHQpe3JldHVybiBuZXcgWSgoKGUsbik9PntsZXQgcixvO3JldHVybiB0aGlzLnRoZW4oKGU9PntvPSExLHI9ZSx0JiZ0KCl9KSwoZT0+e289ITAscj1lLHQmJnQoKX0pKS50aGVuKCgoKT0+e28/bihyKTplKHIpfSkpfSkpfV9faW5pdCgpe3RoaXMuaD10PT57dGhpcy5tKEguUkVTT0xWRUQsdCl9fV9faW5pdDIoKXt0aGlzLnA9dD0+e3RoaXMubShILlJFSkVDVEVELHQpfX1fX2luaXQzKCl7dGhpcy5tPSh0LGUpPT57dGhpcy5pPT09SC5QRU5ESU5HJiYobShlKT9lLnRoZW4odGhpcy5oLHRoaXMucCk6KHRoaXMuaT10LHRoaXMudj1lLHRoaXMubCgpKSl9fV9faW5pdDQoKXt0aGlzLmw9KCk9PntpZih0aGlzLmk9PT1ILlBFTkRJTkcpcmV0dXJuO2NvbnN0IHQ9dGhpcy51LnNsaWNlKCk7dGhpcy51PVtdLHQuZm9yRWFjaCgodD0+e3RbMF18fCh0aGlzLmk9PT1ILlJFU09MVkVEJiZ0WzFdKHRoaXMudiksdGhpcy5pPT09SC5SRUpFQ1RFRCYmdFsyXSh0aGlzLnYpLHRbMF09ITApfSkpfX19ZnVuY3Rpb24gcSh0KXtjb25zdCBlPVtdO2Z1bmN0aW9uIG4odCl7cmV0dXJuIGUuc3BsaWNlKGUuaW5kZXhPZih0KSwxKVswXX1yZXR1cm57JDplLGFkZDpmdW5jdGlvbihyKXtpZighKHZvaWQgMD09PXR8fGUubGVuZ3RoPHQpKXJldHVybiBvPW5ldyBDKCJOb3QgYWRkaW5nIFByb21pc2UgYmVjYXVzZSBidWZmZXIgbGltaXQgd2FzIHJlYWNoZWQuIiksbmV3IFkoKCh0LGUpPT57ZShvKX0pKTt2YXIgbztjb25zdCBzPXIoKTtyZXR1cm4tMT09PWUuaW5kZXhPZihzKSYmZS5wdXNoKHMpLHMudGhlbigoKCk9Pm4ocykpKS50aGVuKG51bGwsKCgpPT5uKHMpLnRoZW4obnVsbCwoKCk9Pnt9KSkpKSxzfSxkcmFpbjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFkoKChuLHIpPT57bGV0IG89ZS5sZW5ndGg7aWYoIW8pcmV0dXJuIG4oITApO2NvbnN0IHM9c2V0VGltZW91dCgoKCk9Pnt0JiZ0PjAmJm4oITEpfSksdCk7ZS5mb3JFYWNoKCh0PT57Vyh0KS50aGVuKCgoKT0+ey0tb3x8KGNsZWFyVGltZW91dChzKSxuKCEwKSl9KSxyKX0pKX0pKX19fWZ1bmN0aW9uIEYodCxlPSExKXtyZXR1cm4hKGV8fHQmJiF0LnN0YXJ0c1dpdGgoIi8iKSYmIXQubWF0Y2goL15bQS1aXTovKSYmIXQuc3RhcnRzV2l0aCgiLiIpJiYhdC5tYXRjaCgvXlthLXpBLVpdKFthLXpBLVowLTkuXC0rXSkqOlwvXC8vKSkmJnZvaWQgMCE9PXQmJiF0LmluY2x1ZGVzKCJub2RlX21vZHVsZXMvIil9Y29uc3QgSz0xZTM7ZnVuY3Rpb24gVigpe3JldHVybiBEYXRlLm5vdygpL0t9Y29uc3QgWj1mdW5jdGlvbigpe2NvbnN0e3BlcmZvcm1hbmNlOnR9PXk7aWYoIXR8fCF0Lm5vdylyZXR1cm4gVjtjb25zdCBlPURhdGUubm93KCktdC5ub3coKSxuPW51bGw9PXQudGltZU9yaWdpbj9lOnQudGltZU9yaWdpbjtyZXR1cm4oKT0+KG4rdC5ub3coKSkvS30oKTtmdW5jdGlvbiBRKHQsZT1bXSl7cmV0dXJuW3QsZV19ZnVuY3Rpb24gWCh0LGUpe2NvbnN0IG49dFsxXTtmb3IoY29uc3QgdCBvZiBuKXtpZihlKHQsdFswXS50eXBlKSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiB0dCh0KXtyZXR1cm4geS5fX1NFTlRSWV9fJiZ5Ll9fU0VOVFJZX18uZW5jb2RlUG9seWZpbGw/eS5fX1NFTlRSWV9fLmVuY29kZVBvbHlmaWxsKHQpOihuZXcgVGV4dEVuY29kZXIpLmVuY29kZSh0KX1mdW5jdGlvbiBldCh0KXtjb25zdFtlLG5dPXQ7bGV0IHI9SlNPTi5zdHJpbmdpZnkoZSk7ZnVuY3Rpb24gbyh0KXsic3RyaW5nIj09dHlwZW9mIHI/cj0ic3RyaW5nIj09dHlwZW9mIHQ/cit0Olt0dChyKSx0XTpyLnB1c2goInN0cmluZyI9PXR5cGVvZiB0P3R0KHQpOnQpfWZvcihjb25zdCB0IG9mIG4pe2NvbnN0W2Usbl09dDtpZihvKGBcbiR7SlNPTi5zdHJpbmdpZnkoZSl9XG5gKSwic3RyaW5nIj09dHlwZW9mIG58fG4gaW5zdGFuY2VvZiBVaW50OEFycmF5KW8obik7ZWxzZXtsZXQgdDt0cnl7dD1KU09OLnN0cmluZ2lmeShuKX1jYXRjaChlKXt0PUpTT04uc3RyaW5naWZ5KEwobikpfW8odCl9fXJldHVybiJzdHJpbmciPT10eXBlb2Ygcj9yOmZ1bmN0aW9uKHQpe2NvbnN0IGU9dC5yZWR1Y2UoKCh0LGUpPT50K2UubGVuZ3RoKSwwKSxuPW5ldyBVaW50OEFycmF5KGUpO2xldCByPTA7Zm9yKGNvbnN0IGUgb2YgdCluLnNldChlLHIpLHIrPWUubGVuZ3RoO3JldHVybiBufShyKX0oKCk9Pntjb25zdHtwZXJmb3JtYW5jZTp0fT15O2lmKCF0fHwhdC5ub3cpcmV0dXJuO2NvbnN0IGU9MzZlNSxuPXQubm93KCkscj1EYXRlLm5vdygpLG89dC50aW1lT3JpZ2luP01hdGguYWJzKHQudGltZU9yaWdpbituLXIpOmUscz1vPGUsaT10LnRpbWluZyYmdC50aW1pbmcubmF2aWdhdGlvblN0YXJ0LGM9Im51bWJlciI9PXR5cGVvZiBpP01hdGguYWJzKGkrbi1yKTplOyhzfHxjPGUpJiYobzw9YyYmdC50aW1lT3JpZ2luKX0pKCk7Y29uc3QgbnQ9e3Nlc3Npb246InNlc3Npb24iLHNlc3Npb25zOiJzZXNzaW9uIixhdHRhY2htZW50OiJhdHRhY2htZW50Iix0cmFuc2FjdGlvbjoidHJhbnNhY3Rpb24iLGV2ZW50OiJlcnJvciIsY2xpZW50X3JlcG9ydDoiaW50ZXJuYWwiLHVzZXJfcmVwb3J0OiJkZWZhdWx0Iixwcm9maWxlOiJwcm9maWxlIixyZXBsYXlfZXZlbnQ6InJlcGxheSIscmVwbGF5X3JlY29yZGluZzoicmVwbGF5IixjaGVja19pbjoibW9uaXRvciIsZmVlZGJhY2s6ImZlZWRiYWNrIixzcGFuOiJzcGFuIixzdGF0c2Q6Im1ldHJpY19idWNrZXQifTtmdW5jdGlvbiBydCh0KXtyZXR1cm4gbnRbdF19ZnVuY3Rpb24gb3QodCl7aWYoIXR8fCF0LnNkaylyZXR1cm47Y29uc3R7bmFtZTplLHZlcnNpb246bn09dC5zZGs7cmV0dXJue25hbWU6ZSx2ZXJzaW9uOm59fWNvbnN0IHN0PTZlNDtmdW5jdGlvbiBpdCh0LHtzdGF0dXNDb2RlOmUsaGVhZGVyczpufSxyPURhdGUubm93KCkpe2NvbnN0IG89ey4uLnR9LHM9biYmblsieC1zZW50cnktcmF0ZS1saW1pdHMiXSxpPW4mJm5bInJldHJ5LWFmdGVyIl07aWYocylmb3IoY29uc3QgdCBvZiBzLnRyaW0oKS5zcGxpdCgiLCIpKXtjb25zdFtlLG4sLCxzXT10LnNwbGl0KCI6Iiw1KSxpPXBhcnNlSW50KGUsMTApLGM9MWUzKihpc05hTihpKT82MDppKTtpZihuKWZvcihjb25zdCB0IG9mIG4uc3BsaXQoIjsiKSkibWV0cmljX2J1Y2tldCI9PT10JiZzJiYhcy5zcGxpdCgiOyIpLmluY2x1ZGVzKCJjdXN0b20iKXx8KG9bdF09citjKTtlbHNlIG8uYWxsPXIrY31lbHNlIGk/by5hbGw9citmdW5jdGlvbih0LGU9RGF0ZS5ub3coKSl7Y29uc3Qgbj1wYXJzZUludChgJHt0fWAsMTApO2lmKCFpc05hTihuKSlyZXR1cm4gMWUzKm47Y29uc3Qgcj1EYXRlLnBhcnNlKGAke3R9YCk7cmV0dXJuIGlzTmFOKHIpP3N0OnItZX0oaSxyKTo0Mjk9PT1lJiYoby5hbGw9cis2ZTQpO3JldHVybiBvfWNvbnN0IGN0PSJ1bmRlZmluZWQiPT10eXBlb2YgX19TRU5UUllfREVCVUdfX3x8X19TRU5UUllfREVCVUdfXztmdW5jdGlvbiB1dCgpe3JldHVybiBhdCh5KSx5fWZ1bmN0aW9uIGF0KHQpe3JldHVybiB0Ll9fU0VOVFJZX198fCh0Ll9fU0VOVFJZX189e2V4dGVuc2lvbnM6e319KSx0Ll9fU0VOVFJZX199ZnVuY3Rpb24gZnQodCl7Y29uc3QgZT1aKCksbj17c2lkOk0oKSxpbml0OiEwLHRpbWVzdGFtcDplLHN0YXJ0ZWQ6ZSxkdXJhdGlvbjowLHN0YXR1czoib2siLGVycm9yczowLGlnbm9yZUR1cmF0aW9uOiExLHRvSlNPTjooKT0+ZnVuY3Rpb24odCl7cmV0dXJuIGooe3NpZDpgJHt0LnNpZH1gLGluaXQ6dC5pbml0LHN0YXJ0ZWQ6bmV3IERhdGUoMWUzKnQuc3RhcnRlZCkudG9JU09TdHJpbmcoKSx0aW1lc3RhbXA6bmV3IERhdGUoMWUzKnQudGltZXN0YW1wKS50b0lTT1N0cmluZygpLHN0YXR1czp0LnN0YXR1cyxlcnJvcnM6dC5lcnJvcnMsZGlkOiJudW1iZXIiPT10eXBlb2YgdC5kaWR8fCJzdHJpbmciPT10eXBlb2YgdC5kaWQ/YCR7dC5kaWR9YDp2b2lkIDAsZHVyYXRpb246dC5kdXJhdGlvbixhYm5vcm1hbF9tZWNoYW5pc206dC5hYm5vcm1hbF9tZWNoYW5pc20sYXR0cnM6e3JlbGVhc2U6dC5yZWxlYXNlLGVudmlyb25tZW50OnQuZW52aXJvbm1lbnQsaXBfYWRkcmVzczp0LmlwQWRkcmVzcyx1c2VyX2FnZW50OnQudXNlckFnZW50fX0pfShuKX07cmV0dXJuIHQmJmh0KG4sdCksbn1mdW5jdGlvbiBodCh0LGU9e30pe2lmKGUudXNlciYmKCF0LmlwQWRkcmVzcyYmZS51c2VyLmlwX2FkZHJlc3MmJih0LmlwQWRkcmVzcz1lLnVzZXIuaXBfYWRkcmVzcyksdC5kaWR8fGUuZGlkfHwodC5kaWQ9ZS51c2VyLmlkfHxlLnVzZXIuZW1haWx8fGUudXNlci51c2VybmFtZSkpLHQudGltZXN0YW1wPWUudGltZXN0YW1wfHxaKCksZS5hYm5vcm1hbF9tZWNoYW5pc20mJih0LmFibm9ybWFsX21lY2hhbmlzbT1lLmFibm9ybWFsX21lY2hhbmlzbSksZS5pZ25vcmVEdXJhdGlvbiYmKHQuaWdub3JlRHVyYXRpb249ZS5pZ25vcmVEdXJhdGlvbiksZS5zaWQmJih0LnNpZD0zMj09PWUuc2lkLmxlbmd0aD9lLnNpZDpNKCkpLHZvaWQgMCE9PWUuaW5pdCYmKHQuaW5pdD1lLmluaXQpLCF0LmRpZCYmZS5kaWQmJih0LmRpZD1gJHtlLmRpZH1gKSwibnVtYmVyIj09dHlwZW9mIGUuc3RhcnRlZCYmKHQuc3RhcnRlZD1lLnN0YXJ0ZWQpLHQuaWdub3JlRHVyYXRpb24pdC5kdXJhdGlvbj12b2lkIDA7ZWxzZSBpZigibnVtYmVyIj09dHlwZW9mIGUuZHVyYXRpb24pdC5kdXJhdGlvbj1lLmR1cmF0aW9uO2Vsc2V7Y29uc3QgZT10LnRpbWVzdGFtcC10LnN0YXJ0ZWQ7dC5kdXJhdGlvbj1lPj0wP2U6MH1lLnJlbGVhc2UmJih0LnJlbGVhc2U9ZS5yZWxlYXNlKSxlLmVudmlyb25tZW50JiYodC5lbnZpcm9ubWVudD1lLmVudmlyb25tZW50KSwhdC5pcEFkZHJlc3MmJmUuaXBBZGRyZXNzJiYodC5pcEFkZHJlc3M9ZS5pcEFkZHJlc3MpLCF0LnVzZXJBZ2VudCYmZS51c2VyQWdlbnQmJih0LnVzZXJBZ2VudD1lLnVzZXJBZ2VudCksIm51bWJlciI9PXR5cGVvZiBlLmVycm9ycyYmKHQuZXJyb3JzPWUuZXJyb3JzKSxlLnN0YXR1cyYmKHQuc3RhdHVzPWUuc3RhdHVzKX1jb25zdCBwdD0iX3NlbnRyeVNwYW4iO2Z1bmN0aW9uIGx0KHQsZSl7ZT9mdW5jdGlvbih0LGUsbil7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LGUse3ZhbHVlOm4sd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfSl9Y2F0Y2gobil7UyYmTi5sb2coYEZhaWxlZCB0byBhZGQgbm9uLWVudW1lcmFibGUgcHJvcGVydHkgIiR7ZX0iIHRvIG9iamVjdGAsdCl9fSh0LHB0LGUpOmRlbGV0ZSB0W3B0XX1mdW5jdGlvbiBkdCh0KXtyZXR1cm4gdFtwdF19Y2xhc3MgbXR7Y29uc3RydWN0b3IoKXt0aGlzLl89ITEsdGhpcy5TPVtdLHRoaXMuTj1bXSx0aGlzLms9W10sdGhpcy5DPVtdLHRoaXMuRD17fSx0aGlzLlQ9e30sdGhpcy5PPXt9LHRoaXMuaj17fSx0aGlzLlI9e30sdGhpcy5BPWd0KCl9Y2xvbmUoKXtjb25zdCB0PW5ldyBtdDtyZXR1cm4gdC5rPVsuLi50aGlzLmtdLHQuVD17Li4udGhpcy5UfSx0Lk89ey4uLnRoaXMuT30sdC5qPXsuLi50aGlzLmp9LHQuRD10aGlzLkQsdC5JPXRoaXMuSSx0LlA9dGhpcy5QLHQuVT10aGlzLlUsdC5NPXRoaXMuTSx0Lk49Wy4uLnRoaXMuTl0sdC5MPXRoaXMuTCx0LkM9Wy4uLnRoaXMuQ10sdC5SPXsuLi50aGlzLlJ9LHQuQT17Li4udGhpcy5BfSx0LkI9dGhpcy5CLGx0KHQsZHQodGhpcykpLHR9c2V0Q2xpZW50KHQpe3RoaXMuQj10fWdldENsaWVudCgpe3JldHVybiB0aGlzLkJ9YWRkU2NvcGVMaXN0ZW5lcih0KXt0aGlzLlMucHVzaCh0KX1hZGRFdmVudFByb2Nlc3Nvcih0KXtyZXR1cm4gdGhpcy5OLnB1c2godCksdGhpc31zZXRVc2VyKHQpe3JldHVybiB0aGlzLkQ9dHx8e2VtYWlsOnZvaWQgMCxpZDp2b2lkIDAsaXBfYWRkcmVzczp2b2lkIDAsdXNlcm5hbWU6dm9pZCAwfSx0aGlzLlAmJmh0KHRoaXMuUCx7dXNlcjp0fSksdGhpcy5HKCksdGhpc31nZXRVc2VyKCl7cmV0dXJuIHRoaXMuRH1nZXRSZXF1ZXN0U2Vzc2lvbigpe3JldHVybiB0aGlzLkx9c2V0UmVxdWVzdFNlc3Npb24odCl7cmV0dXJuIHRoaXMuTD10LHRoaXN9c2V0VGFncyh0KXtyZXR1cm4gdGhpcy5UPXsuLi50aGlzLlQsLi4udH0sdGhpcy5HKCksdGhpc31zZXRUYWcodCxlKXtyZXR1cm4gdGhpcy5UPXsuLi50aGlzLlQsW3RdOmV9LHRoaXMuRygpLHRoaXN9c2V0RXh0cmFzKHQpe3JldHVybiB0aGlzLk89ey4uLnRoaXMuTywuLi50fSx0aGlzLkcoKSx0aGlzfXNldEV4dHJhKHQsZSl7cmV0dXJuIHRoaXMuTz17Li4udGhpcy5PLFt0XTplfSx0aGlzLkcoKSx0aGlzfXNldEZpbmdlcnByaW50KHQpe3JldHVybiB0aGlzLk09dCx0aGlzLkcoKSx0aGlzfXNldExldmVsKHQpe3JldHVybiB0aGlzLkk9dCx0aGlzLkcoKSx0aGlzfXNldFRyYW5zYWN0aW9uTmFtZSh0KXtyZXR1cm4gdGhpcy5VPXQsdGhpcy5HKCksdGhpc31zZXRDb250ZXh0KHQsZSl7cmV0dXJuIG51bGw9PT1lP2RlbGV0ZSB0aGlzLmpbdF06dGhpcy5qW3RdPWUsdGhpcy5HKCksdGhpc31zZXRTZXNzaW9uKHQpe3JldHVybiB0P3RoaXMuUD10OmRlbGV0ZSB0aGlzLlAsdGhpcy5HKCksdGhpc31nZXRTZXNzaW9uKCl7cmV0dXJuIHRoaXMuUH11cGRhdGUodCl7aWYoIXQpcmV0dXJuIHRoaXM7Y29uc3QgZT0iZnVuY3Rpb24iPT10eXBlb2YgdD90KHRoaXMpOnQsW24scl09ZSBpbnN0YW5jZW9mIG10P1tlLmdldFNjb3BlRGF0YSgpLGUuZ2V0UmVxdWVzdFNlc3Npb24oKV06ZChlKT9bdCx0LnJlcXVlc3RTZXNzaW9uXTpbXSx7dGFnczpvLGV4dHJhOnMsdXNlcjppLGNvbnRleHRzOmMsbGV2ZWw6dSxmaW5nZXJwcmludDphPVtdLHByb3BhZ2F0aW9uQ29udGV4dDpmfT1ufHx7fTtyZXR1cm4gdGhpcy5UPXsuLi50aGlzLlQsLi4ub30sdGhpcy5PPXsuLi50aGlzLk8sLi4uc30sdGhpcy5qPXsuLi50aGlzLmosLi4uY30saSYmT2JqZWN0LmtleXMoaSkubGVuZ3RoJiYodGhpcy5EPWkpLHUmJih0aGlzLkk9dSksYS5sZW5ndGgmJih0aGlzLk09YSksZiYmKHRoaXMuQT1mKSxyJiYodGhpcy5MPXIpLHRoaXN9Y2xlYXIoKXtyZXR1cm4gdGhpcy5rPVtdLHRoaXMuVD17fSx0aGlzLk89e30sdGhpcy5EPXt9LHRoaXMuaj17fSx0aGlzLkk9dm9pZCAwLHRoaXMuVT12b2lkIDAsdGhpcy5NPXZvaWQgMCx0aGlzLkw9dm9pZCAwLHRoaXMuUD12b2lkIDAsbHQodGhpcyx2b2lkIDApLHRoaXMuQz1bXSx0aGlzLkE9Z3QoKSx0aGlzLkcoKSx0aGlzfWFkZEJyZWFkY3J1bWIodCxlKXtjb25zdCBuPSJudW1iZXIiPT10eXBlb2YgZT9lOjEwMDtpZihuPD0wKXJldHVybiB0aGlzO2NvbnN0IHI9e3RpbWVzdGFtcDpWKCksLi4udH0sbz10aGlzLms7cmV0dXJuIG8ucHVzaChyKSx0aGlzLms9by5sZW5ndGg+bj9vLnNsaWNlKC1uKTpvLHRoaXMuRygpLHRoaXN9Z2V0TGFzdEJyZWFkY3J1bWIoKXtyZXR1cm4gdGhpcy5rW3RoaXMuay5sZW5ndGgtMV19Y2xlYXJCcmVhZGNydW1icygpe3JldHVybiB0aGlzLms9W10sdGhpcy5HKCksdGhpc31hZGRBdHRhY2htZW50KHQpe3JldHVybiB0aGlzLkMucHVzaCh0KSx0aGlzfWNsZWFyQXR0YWNobWVudHMoKXtyZXR1cm4gdGhpcy5DPVtdLHRoaXN9Z2V0U2NvcGVEYXRhKCl7cmV0dXJue2JyZWFkY3J1bWJzOnRoaXMuayxhdHRhY2htZW50czp0aGlzLkMsY29udGV4dHM6dGhpcy5qLHRhZ3M6dGhpcy5ULGV4dHJhOnRoaXMuTyx1c2VyOnRoaXMuRCxsZXZlbDp0aGlzLkksZmluZ2VycHJpbnQ6dGhpcy5NfHxbXSxldmVudFByb2Nlc3NvcnM6dGhpcy5OLHByb3BhZ2F0aW9uQ29udGV4dDp0aGlzLkEsc2RrUHJvY2Vzc2luZ01ldGFkYXRhOnRoaXMuUix0cmFuc2FjdGlvbk5hbWU6dGhpcy5VLHNwYW46ZHQodGhpcyl9fXNldFNES1Byb2Nlc3NpbmdNZXRhZGF0YSh0KXtyZXR1cm4gdGhpcy5SPXsuLi50aGlzLlIsLi4udH0sdGhpc31zZXRQcm9wYWdhdGlvbkNvbnRleHQodCl7cmV0dXJuIHRoaXMuQT10LHRoaXN9Z2V0UHJvcGFnYXRpb25Db250ZXh0KCl7cmV0dXJuIHRoaXMuQX1jYXB0dXJlRXhjZXB0aW9uKHQsZSl7Y29uc3Qgbj1lJiZlLmV2ZW50X2lkP2UuZXZlbnRfaWQ6TSgpO2lmKCF0aGlzLkIpcmV0dXJuIE4ud2FybigiTm8gY2xpZW50IGNvbmZpZ3VyZWQgb24gc2NvcGUgLSB3aWxsIG5vdCBjYXB0dXJlIGV4Y2VwdGlvbiEiKSxuO2NvbnN0IHI9bmV3IEVycm9yKCJTZW50cnkgc3ludGhldGljRXhjZXB0aW9uIik7cmV0dXJuIHRoaXMuQi5jYXB0dXJlRXhjZXB0aW9uKHQse29yaWdpbmFsRXhjZXB0aW9uOnQsc3ludGhldGljRXhjZXB0aW9uOnIsLi4uZSxldmVudF9pZDpufSx0aGlzKSxufWNhcHR1cmVNZXNzYWdlKHQsZSxuKXtjb25zdCByPW4mJm4uZXZlbnRfaWQ/bi5ldmVudF9pZDpNKCk7aWYoIXRoaXMuQilyZXR1cm4gTi53YXJuKCJObyBjbGllbnQgY29uZmlndXJlZCBvbiBzY29wZSAtIHdpbGwgbm90IGNhcHR1cmUgbWVzc2FnZSEiKSxyO2NvbnN0IG89bmV3IEVycm9yKHQpO3JldHVybiB0aGlzLkIuY2FwdHVyZU1lc3NhZ2UodCxlLHtvcmlnaW5hbEV4Y2VwdGlvbjp0LHN5bnRoZXRpY0V4Y2VwdGlvbjpvLC4uLm4sZXZlbnRfaWQ6cn0sdGhpcykscn1jYXB0dXJlRXZlbnQodCxlKXtjb25zdCBuPWUmJmUuZXZlbnRfaWQ/ZS5ldmVudF9pZDpNKCk7cmV0dXJuIHRoaXMuQj8odGhpcy5CLmNhcHR1cmVFdmVudCh0LHsuLi5lLGV2ZW50X2lkOm59LHRoaXMpLG4pOihOLndhcm4oIk5vIGNsaWVudCBjb25maWd1cmVkIG9uIHNjb3BlIC0gd2lsbCBub3QgY2FwdHVyZSBldmVudCEiKSxuKX1HKCl7dGhpcy5ffHwodGhpcy5fPSEwLHRoaXMuUy5mb3JFYWNoKCh0PT57dCh0aGlzKX0pKSx0aGlzLl89ITEpfX1mdW5jdGlvbiBndCgpe3JldHVybnt0cmFjZUlkOk0oKSxzcGFuSWQ6TSgpLnN1YnN0cmluZygxNil9fWZ1bmN0aW9uIHl0KCl7cmV0dXJuICR0KHV0KCkpLmdldEN1cnJlbnRTY29wZSgpLmdldENsaWVudCgpfWNsYXNzIGJ0e2NvbnN0cnVjdG9yKHQsZSl7bGV0IG4scjtuPXR8fG5ldyBtdCxyPWV8fG5ldyBtdCx0aGlzLko9W3tzY29wZTpufV0sdGhpcy5IPXJ9d2l0aFNjb3BlKHQpe2NvbnN0IGU9dGhpcy5XKCk7bGV0IG47dHJ5e249dChlKX1jYXRjaCh0KXt0aHJvdyB0aGlzLlkoKSx0fXJldHVybiBtKG4pP24udGhlbigodD0+KHRoaXMuWSgpLHQpKSwodD0+e3Rocm93IHRoaXMuWSgpLHR9KSk6KHRoaXMuWSgpLG4pfWdldENsaWVudCgpe3JldHVybiB0aGlzLmdldFN0YWNrVG9wKCkuY2xpZW50fWdldFNjb3BlKCl7cmV0dXJuIHRoaXMuZ2V0U3RhY2tUb3AoKS5zY29wZX1nZXRJc29sYXRpb25TY29wZSgpe3JldHVybiB0aGlzLkh9Z2V0U3RhY2soKXtyZXR1cm4gdGhpcy5KfWdldFN0YWNrVG9wKCl7cmV0dXJuIHRoaXMuSlt0aGlzLkoubGVuZ3RoLTFdfVcoKXtjb25zdCB0PXRoaXMuZ2V0U2NvcGUoKS5jbG9uZSgpO3JldHVybiB0aGlzLmdldFN0YWNrKCkucHVzaCh7Y2xpZW50OnRoaXMuZ2V0Q2xpZW50KCksc2NvcGU6dH0pLHR9WSgpe3JldHVybiEodGhpcy5nZXRTdGFjaygpLmxlbmd0aDw9MSkmJiEhdGhpcy5nZXRTdGFjaygpLnBvcCgpfX1mdW5jdGlvbiB2dCgpe2NvbnN0IHQ9YXQodXQoKSk7cmV0dXJuIHQuaHVifHwodC5odWI9bmV3IGJ0KGIoImRlZmF1bHRDdXJyZW50U2NvcGUiLCgoKT0+bmV3IG10KSksYigiZGVmYXVsdElzb2xhdGlvblNjb3BlIiwoKCk9Pm5ldyBtdCkpKSksdC5odWJ9ZnVuY3Rpb24gX3QodCl7cmV0dXJuIHZ0KCkud2l0aFNjb3BlKHQpfWZ1bmN0aW9uIHd0KHQsZSl7Y29uc3Qgbj12dCgpO3JldHVybiBuLndpdGhTY29wZSgoKCk9PihuLmdldFN0YWNrVG9wKCkuc2NvcGU9dCxlKHQpKSkpfWZ1bmN0aW9uIFN0KHQpe3JldHVybiB2dCgpLndpdGhTY29wZSgoKCk9PnQodnQoKS5nZXRJc29sYXRpb25TY29wZSgpKSkpfWZ1bmN0aW9uICR0KHQpe2NvbnN0IGU9YXQodCk7cmV0dXJuIGUuYWNzP2UuYWNzOnt3aXRoSXNvbGF0aW9uU2NvcGU6U3Qsd2l0aFNjb3BlOl90LHdpdGhTZXRTY29wZTp3dCx3aXRoU2V0SXNvbGF0aW9uU2NvcGU6KHQsZSk9PlN0KGUpLGdldEN1cnJlbnRTY29wZTooKT0+dnQoKS5nZXRTY29wZSgpLGdldElzb2xhdGlvblNjb3BlOigpPT52dCgpLmdldElzb2xhdGlvblNjb3BlKCl9fWNvbnN0IEV0PSJzZW50cnkuc291cmNlIix4dD0ic2VudHJ5LnNhbXBsZV9yYXRlIixOdD0ic2VudHJ5Lm9wIixrdD0ic2VudHJ5Lm9yaWdpbiIsQ3Q9MCxEdD0xLFR0PSJwcm9kdWN0aW9uIixPdD0iX2Zyb3plbkRzYyI7ZnVuY3Rpb24ganQodCl7Y29uc3QgZT15dCgpO2lmKCFlKXJldHVybnt9O2NvbnN0IG49ZnVuY3Rpb24odCxlKXtjb25zdCBuPWUuZ2V0T3B0aW9ucygpLHtwdWJsaWNLZXk6cn09ZS5nZXREc24oKXx8e30sbz1qKHtlbnZpcm9ubWVudDpuLmVudmlyb25tZW50fHxUdCxyZWxlYXNlOm4ucmVsZWFzZSxwdWJsaWNfa2V5OnIsdHJhY2VfaWQ6dH0pO3JldHVybiBlLmVtaXQoImNyZWF0ZURzYyIsbyksb30oVXQodCkudHJhY2VfaWR8fCIiLGUpLHI9QnQodCk7aWYoIXIpcmV0dXJuIG47Y29uc3Qgbz1yW090XTtpZihvKXJldHVybiBvO2NvbnN0IHM9VXQociksaT1zLmRhdGF8fHt9LGM9aVt4dF07bnVsbCE9YyYmKG4uc2FtcGxlX3JhdGU9YCR7Y31gKTtjb25zdCB1PWlbRXRdO3JldHVybiB1JiYidXJsIiE9PXUmJihuLnRyYW5zYWN0aW9uPXMuZGVzY3JpcHRpb24pLG4uc2FtcGxlZD1TdHJpbmcoZnVuY3Rpb24odCl7Y29uc3R7dHJhY2VGbGFnczplfT10LnNwYW5Db250ZXh0KCk7cmV0dXJuIGU9PT1SdH0ocikpLGUuZW1pdCgiY3JlYXRlRHNjIixuKSxufWNvbnN0IFJ0PTE7ZnVuY3Rpb24gQXQodCl7Y29uc3R7c3BhbklkOmUsdHJhY2VJZDpufT10LnNwYW5Db250ZXh0KCkse3BhcmVudF9zcGFuX2lkOnJ9PVV0KHQpO3JldHVybiBqKHtwYXJlbnRfc3Bhbl9pZDpyLHNwYW5faWQ6ZSx0cmFjZV9pZDpufSl9ZnVuY3Rpb24gSXQodCl7cmV0dXJuIm51bWJlciI9PXR5cGVvZiB0P1B0KHQpOkFycmF5LmlzQXJyYXkodCk/dFswXSt0WzFdLzFlOTp0IGluc3RhbmNlb2YgRGF0ZT9QdCh0LmdldFRpbWUoKSk6WigpfWZ1bmN0aW9uIFB0KHQpe3JldHVybiB0Pjk5OTk5OTk5OTk/dC8xZTM6dH1mdW5jdGlvbiBVdCh0KXtpZihmdW5jdGlvbih0KXtyZXR1cm4iZnVuY3Rpb24iPT10eXBlb2YgdC5nZXRTcGFuSlNPTn0odCkpcmV0dXJuIHQuZ2V0U3BhbkpTT04oKTt0cnl7Y29uc3R7c3BhbklkOmUsdHJhY2VJZDpufT10LnNwYW5Db250ZXh0KCk7aWYoZnVuY3Rpb24odCl7Y29uc3QgZT10O3JldHVybiEhKGUuYXR0cmlidXRlcyYmZS5zdGFydFRpbWUmJmUubmFtZSYmZS5lbmRUaW1lJiZlLnN0YXR1cyl9KHQpKXtjb25zdHthdHRyaWJ1dGVzOnIsc3RhcnRUaW1lOm8sbmFtZTpzLGVuZFRpbWU6aSxwYXJlbnRTcGFuSWQ6YyxzdGF0dXM6dX09dDtyZXR1cm4gaih7c3Bhbl9pZDplLHRyYWNlX2lkOm4sZGF0YTpyLGRlc2NyaXB0aW9uOnMscGFyZW50X3NwYW5faWQ6YyxzdGFydF90aW1lc3RhbXA6SXQobyksdGltZXN0YW1wOkl0KGkpfHx2b2lkIDAsc3RhdHVzOk10KHUpLG9wOnJbTnRdLG9yaWdpbjpyW2t0XSxxOnZvaWQgMH0pfXJldHVybntzcGFuX2lkOmUsdHJhY2VfaWQ6bn19Y2F0Y2godCl7cmV0dXJue319fWZ1bmN0aW9uIE10KHQpe2lmKHQmJnQuY29kZSE9PUN0KXJldHVybiB0LmNvZGU9PT1EdD8ib2siOnQubWVzc2FnZXx8InVua25vd25fZXJyb3IifWNvbnN0IEx0PSJfc2VudHJ5Um9vdFNwYW4iO2Z1bmN0aW9uIEJ0KHQpe3JldHVybiB0W0x0XXx8dH1mdW5jdGlvbiBHdCh0LGUsbixyKXtjb25zdCBvPW90KG4pLHM9dC50eXBlJiYicmVwbGF5X2V2ZW50IiE9PXQudHlwZT90LnR5cGU6ImV2ZW50IjshZnVuY3Rpb24odCxlKXtlJiYodC5zZGs9dC5zZGt8fHt9LHQuc2RrLm5hbWU9dC5zZGsubmFtZXx8ZS5uYW1lLHQuc2RrLnZlcnNpb249dC5zZGsudmVyc2lvbnx8ZS52ZXJzaW9uLHQuc2RrLmludGVncmF0aW9ucz1bLi4udC5zZGsuaW50ZWdyYXRpb25zfHxbXSwuLi5lLmludGVncmF0aW9uc3x8W11dLHQuc2RrLnBhY2thZ2VzPVsuLi50LnNkay5wYWNrYWdlc3x8W10sLi4uZS5wYWNrYWdlc3x8W11dKX0odCxuJiZuLnNkayk7Y29uc3QgaT1mdW5jdGlvbih0LGUsbixyKXtjb25zdCBvPXQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhJiZ0LnNka1Byb2Nlc3NpbmdNZXRhZGF0YS5keW5hbWljU2FtcGxpbmdDb250ZXh0O3JldHVybntldmVudF9pZDp0LmV2ZW50X2lkLHNlbnRfYXQ6KG5ldyBEYXRlKS50b0lTT1N0cmluZygpLC4uLmUmJntzZGs6ZX0sLi4uISFuJiZyJiZ7ZHNuOmsocil9LC4uLm8mJnt0cmFjZTpqKHsuLi5vfSl9fX0odCxvLHIsZSk7ZGVsZXRlIHQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhO3JldHVybiBRKGksW1t7dHlwZTpzfSx0XV0pfWNvbnN0IEp0PSJfX1NFTlRSWV9TVVBQUkVTU19UUkFDSU5HX18iO2Z1bmN0aW9uIHp0KHQpe2NvbnN0IGU9JHQodXQoKSk7cmV0dXJuIGUuc3VwcHJlc3NUcmFjaW5nP2Uuc3VwcHJlc3NUcmFjaW5nKHQpOmZ1bmN0aW9uKC4uLnQpe2NvbnN0IGU9JHQodXQoKSk7aWYoMj09PXQubGVuZ3RoKXtjb25zdFtuLHJdPXQ7cmV0dXJuIG4/ZS53aXRoU2V0U2NvcGUobixyKTplLndpdGhTY29wZShyKX1yZXR1cm4gZS53aXRoU2NvcGUodFswXSl9KChlPT4oZS5zZXRTREtQcm9jZXNzaW5nTWV0YWRhdGEoe1tKdF06ITB9KSx0KCkpKSl9ZnVuY3Rpb24gSHQodCxlKXtjb25zdHtmaW5nZXJwcmludDpuLHNwYW46cixicmVhZGNydW1iczpvLHNka1Byb2Nlc3NpbmdNZXRhZGF0YTpzfT1lOyFmdW5jdGlvbih0LGUpe2NvbnN0e2V4dHJhOm4sdGFnczpyLHVzZXI6byxjb250ZXh0czpzLGxldmVsOmksdHJhbnNhY3Rpb25OYW1lOmN9PWUsdT1qKG4pO3UmJk9iamVjdC5rZXlzKHUpLmxlbmd0aCYmKHQuZXh0cmE9ey4uLnUsLi4udC5leHRyYX0pO2NvbnN0IGE9aihyKTthJiZPYmplY3Qua2V5cyhhKS5sZW5ndGgmJih0LnRhZ3M9ey4uLmEsLi4udC50YWdzfSk7Y29uc3QgZj1qKG8pO2YmJk9iamVjdC5rZXlzKGYpLmxlbmd0aCYmKHQudXNlcj17Li4uZiwuLi50LnVzZXJ9KTtjb25zdCBoPWoocyk7aCYmT2JqZWN0LmtleXMoaCkubGVuZ3RoJiYodC5jb250ZXh0cz17Li4uaCwuLi50LmNvbnRleHRzfSk7aSYmKHQubGV2ZWw9aSk7YyYmInRyYW5zYWN0aW9uIiE9PXQudHlwZSYmKHQudHJhbnNhY3Rpb249Yyl9KHQsZSksciYmZnVuY3Rpb24odCxlKXt0LmNvbnRleHRzPXt0cmFjZTpBdChlKSwuLi50LmNvbnRleHRzfSx0LnNka1Byb2Nlc3NpbmdNZXRhZGF0YT17ZHluYW1pY1NhbXBsaW5nQ29udGV4dDpqdChlKSwuLi50LnNka1Byb2Nlc3NpbmdNZXRhZGF0YX07Y29uc3Qgbj1CdChlKSxyPVV0KG4pLmRlc2NyaXB0aW9uO3ImJiF0LnRyYW5zYWN0aW9uJiYidHJhbnNhY3Rpb24iPT09dC50eXBlJiYodC50cmFuc2FjdGlvbj1yKX0odCxyKSxmdW5jdGlvbih0LGUpe3QuZmluZ2VycHJpbnQ9dC5maW5nZXJwcmludD9mdW5jdGlvbih0KXtyZXR1cm4gQXJyYXkuaXNBcnJheSh0KT90Olt0XX0odC5maW5nZXJwcmludCk6W10sZSYmKHQuZmluZ2VycHJpbnQ9dC5maW5nZXJwcmludC5jb25jYXQoZSkpO3QuZmluZ2VycHJpbnQmJiF0LmZpbmdlcnByaW50Lmxlbmd0aCYmZGVsZXRlIHQuZmluZ2VycHJpbnR9KHQsbiksZnVuY3Rpb24odCxlKXtjb25zdCBuPVsuLi50LmJyZWFkY3J1bWJzfHxbXSwuLi5lXTt0LmJyZWFkY3J1bWJzPW4ubGVuZ3RoP246dm9pZCAwfSh0LG8pLGZ1bmN0aW9uKHQsZSl7dC5zZGtQcm9jZXNzaW5nTWV0YWRhdGE9ey4uLnQuc2RrUHJvY2Vzc2luZ01ldGFkYXRhLC4uLmV9fSh0LHMpfWNvbnN0IFd0PSI3IjtmdW5jdGlvbiBZdCh0LGUpe3JldHVybiBuPXtzZW50cnlfa2V5OnQucHVibGljS2V5LHNlbnRyeV92ZXJzaW9uOld0LC4uLmUmJntzZW50cnlfY2xpZW50OmAke2UubmFtZX0vJHtlLnZlcnNpb259YH19LE9iamVjdC5rZXlzKG4pLm1hcCgodD0+YCR7ZW5jb2RlVVJJQ29tcG9uZW50KHQpfT0ke2VuY29kZVVSSUNvbXBvbmVudChuW3RdKX1gKSkuam9pbigiJiIpO3ZhciBufWNvbnN0IHF0PTY0O2Z1bmN0aW9uIEZ0KHQsZSxuPXEodC5idWZmZXJTaXplfHxxdCkpe2xldCByPXt9O3JldHVybntzZW5kOmZ1bmN0aW9uKG8pe2NvbnN0IHM9W107aWYoWChvLCgoZSxuKT0+e2NvbnN0IG89cnQobik7aWYoZnVuY3Rpb24odCxlLG49RGF0ZS5ub3coKSl7cmV0dXJuIGZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRbZV18fHQuYWxsfHwwfSh0LGUpPm59KHIsbykpe2NvbnN0IHI9S3QoZSxuKTt0LnJlY29yZERyb3BwZWRFdmVudCgicmF0ZWxpbWl0X2JhY2tvZmYiLG8scil9ZWxzZSBzLnB1c2goZSl9KSksMD09PXMubGVuZ3RoKXJldHVybiBXKHt9KTtjb25zdCBpPVEob1swXSxzKSxjPWU9PntYKGksKChuLHIpPT57Y29uc3Qgbz1LdChuLHIpO3QucmVjb3JkRHJvcHBlZEV2ZW50KGUscnQociksbyl9KSl9O3JldHVybiBuLmFkZCgoKCk9PmUoe2JvZHk6ZXQoaSl9KS50aGVuKCh0PT4odm9pZCAwIT09dC5zdGF0dXNDb2RlJiYodC5zdGF0dXNDb2RlPDIwMHx8dC5zdGF0dXNDb2RlPj0zMDApJiZjdCYmTi53YXJuKGBTZW50cnkgcmVzcG9uZGVkIHdpdGggc3RhdHVzIGNvZGUgJHt0LnN0YXR1c0NvZGV9IHRvIHNlbnQgZXZlbnQuYCkscj1pdChyLHQpLHQpKSwodD0+e3Rocm93IGMoIm5ldHdvcmtfZXJyb3IiKSx0fSkpKSkudGhlbigodD0+dCksKHQ9PntpZih0IGluc3RhbmNlb2YgQylyZXR1cm4gY3QmJk4uZXJyb3IoIlNraXBwZWQgc2VuZGluZyBldmVudCBiZWNhdXNlIGJ1ZmZlciBpcyBmdWxsLiIpLGMoInF1ZXVlX292ZXJmbG93IiksVyh7fSk7dGhyb3cgdH0pKX0sZmx1c2g6dD0+bi5kcmFpbih0KX19ZnVuY3Rpb24gS3QodCxlKXtpZigiZXZlbnQiPT09ZXx8InRyYW5zYWN0aW9uIj09PWUpcmV0dXJuIEFycmF5LmlzQXJyYXkodCk/dFsxXTp2b2lkIDB9Y29uc3QgVnQ9U3ltYm9sKCJBZ2VudEJhc2VJbnRlcm5hbFN0YXRlIik7Y2xhc3MgWnQgZXh0ZW5kcyBoLkFnZW50e1tWdF07b3B0aW9ucztrZWVwQWxpdmU7Y29uc3RydWN0b3IodCl7c3VwZXIodCksdGhpc1tWdF09e319aXNTZWN1cmVFbmRwb2ludCh0KXtpZih0KXtpZigiYm9vbGVhbiI9PXR5cGVvZiB0LnNlY3VyZUVuZHBvaW50KXJldHVybiB0LnNlY3VyZUVuZHBvaW50O2lmKCJzdHJpbmciPT10eXBlb2YgdC5wcm90b2NvbClyZXR1cm4iaHR0cHM6Ij09PXQucHJvdG9jb2x9Y29uc3R7c3RhY2s6ZX09bmV3IEVycm9yO3JldHVybiJzdHJpbmciPT10eXBlb2YgZSYmZS5zcGxpdCgiXG4iKS5zb21lKCh0PT4tMSE9PXQuaW5kZXhPZigiKGh0dHBzLmpzOiIpfHwtMSE9PXQuaW5kZXhPZigibm9kZTpodHRwczoiKSkpfWNyZWF0ZVNvY2tldCh0LGUsbil7Y29uc3Qgcj17Li4uZSxzZWN1cmVFbmRwb2ludDp0aGlzLmlzU2VjdXJlRW5kcG9pbnQoZSl9O1Byb21pc2UucmVzb2x2ZSgpLnRoZW4oKCgpPT50aGlzLmNvbm5lY3QodCxyKSkpLnRoZW4oKG89PntpZihvIGluc3RhbmNlb2YgaC5BZ2VudClyZXR1cm4gby5hZGRSZXF1ZXN0KHQscik7dGhpc1tWdF0uY3VycmVudFNvY2tldD1vLHN1cGVyLmNyZWF0ZVNvY2tldCh0LGUsbil9KSxuKX1jcmVhdGVDb25uZWN0aW9uKCl7Y29uc3QgdD10aGlzW1Z0XS5jdXJyZW50U29ja2V0O2lmKHRoaXNbVnRdLmN1cnJlbnRTb2NrZXQ9dm9pZCAwLCF0KXRocm93IG5ldyBFcnJvcigiTm8gc29ja2V0IHdhcyByZXR1cm5lZCBpbiB0aGUgYGNvbm5lY3QoKWAgZnVuY3Rpb24iKTtyZXR1cm4gdH1nZXQgZGVmYXVsdFBvcnQoKXtyZXR1cm4gdGhpc1tWdF0uZGVmYXVsdFBvcnQ/PygiaHR0cHM6Ij09PXRoaXMucHJvdG9jb2w/NDQzOjgwKX1zZXQgZGVmYXVsdFBvcnQodCl7dGhpc1tWdF0mJih0aGlzW1Z0XS5kZWZhdWx0UG9ydD10KX1nZXQgcHJvdG9jb2woKXtyZXR1cm4gdGhpc1tWdF0ucHJvdG9jb2w/Pyh0aGlzLmlzU2VjdXJlRW5kcG9pbnQoKT8iaHR0cHM6IjoiaHR0cDoiKX1zZXQgcHJvdG9jb2wodCl7dGhpc1tWdF0mJih0aGlzW1Z0XS5wcm90b2NvbD10KX19ZnVuY3Rpb24gUXQoLi4udCl7Ti5sb2coIltodHRwcy1wcm94eS1hZ2VudDpwYXJzZS1wcm94eS1yZXNwb25zZV0iLC4uLnQpfWZ1bmN0aW9uIFh0KHQpe3JldHVybiBuZXcgUHJvbWlzZSgoKGUsbik9PntsZXQgcj0wO2NvbnN0IG89W107ZnVuY3Rpb24gcygpe2NvbnN0IGM9dC5yZWFkKCk7Yz9mdW5jdGlvbihjKXtvLnB1c2goYykscis9Yy5sZW5ndGg7Y29uc3QgdT1CdWZmZXIuY29uY2F0KG8sciksYT11LmluZGV4T2YoIlxyXG5cclxuIik7aWYoLTE9PT1hKXJldHVybiBRdCgiaGF2ZSBub3QgcmVjZWl2ZWQgZW5kIG9mIEhUVFAgaGVhZGVycyB5ZXQuLi4iKSx2b2lkIHMoKTtjb25zdCBmPXUuc2xpY2UoMCxhKS50b1N0cmluZygiYXNjaWkiKS5zcGxpdCgiXHJcbiIpLGg9Zi5zaGlmdCgpO2lmKCFoKXJldHVybiB0LmRlc3Ryb3koKSxuKG5ldyBFcnJvcigiTm8gaGVhZGVyIHJlY2VpdmVkIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZSIpKTtjb25zdCBwPWguc3BsaXQoIiAiKSxsPStwWzFdLGQ9cC5zbGljZSgyKS5qb2luKCIgIiksbT17fTtmb3IoY29uc3QgZSBvZiBmKXtpZighZSljb250aW51ZTtjb25zdCByPWUuaW5kZXhPZigiOiIpO2lmKC0xPT09cilyZXR1cm4gdC5kZXN0cm95KCksbihuZXcgRXJyb3IoYEludmFsaWQgaGVhZGVyIGZyb20gcHJveHkgQ09OTkVDVCByZXNwb25zZTogIiR7ZX0iYCkpO2NvbnN0IG89ZS5zbGljZSgwLHIpLnRvTG93ZXJDYXNlKCkscz1lLnNsaWNlKHIrMSkudHJpbVN0YXJ0KCksaT1tW29dOyJzdHJpbmciPT10eXBlb2YgaT9tW29dPVtpLHNdOkFycmF5LmlzQXJyYXkoaSk/aS5wdXNoKHMpOm1bb109c31RdCgiZ290IHByb3h5IHNlcnZlciByZXNwb25zZTogJW8gJW8iLGgsbSksaSgpLGUoe2Nvbm5lY3Q6e3N0YXR1c0NvZGU6bCxzdGF0dXNUZXh0OmQsaGVhZGVyczptfSxidWZmZXJlZDp1fSl9KGMpOnQub25jZSgicmVhZGFibGUiLHMpfWZ1bmN0aW9uIGkoKXt0LnJlbW92ZUxpc3RlbmVyKCJlbmQiLGMpLHQucmVtb3ZlTGlzdGVuZXIoImVycm9yIix1KSx0LnJlbW92ZUxpc3RlbmVyKCJyZWFkYWJsZSIscyl9ZnVuY3Rpb24gYygpe2koKSxRdCgib25lbmQiKSxuKG5ldyBFcnJvcigiUHJveHkgY29ubmVjdGlvbiBlbmRlZCBiZWZvcmUgcmVjZWl2aW5nIENPTk5FQ1QgcmVzcG9uc2UiKSl9ZnVuY3Rpb24gdSh0KXtpKCksUXQoIm9uZXJyb3IgJW8iLHQpLG4odCl9dC5vbigiZXJyb3IiLHUpLHQub24oImVuZCIsYykscygpfSkpfWZ1bmN0aW9uIHRlKC4uLnQpe04ubG9nKCJbaHR0cHMtcHJveHktYWdlbnRdIiwuLi50KX1jbGFzcyBlZSBleHRlbmRzIFp0e3N0YXRpYyBwcm90b2NvbHM9WyJodHRwIiwiaHR0cHMiXTtwcm94eTtwcm94eUhlYWRlcnM7Y29ubmVjdE9wdHM7Y29uc3RydWN0b3IodCxlKXtzdXBlcihlKSx0aGlzLm9wdGlvbnM9e30sdGhpcy5wcm94eT0ic3RyaW5nIj09dHlwZW9mIHQ/bmV3IFVSTCh0KTp0LHRoaXMucHJveHlIZWFkZXJzPWU/LmhlYWRlcnM/P3t9LHRlKCJDcmVhdGluZyBuZXcgSHR0cHNQcm94eUFnZW50IGluc3RhbmNlOiAlbyIsdGhpcy5wcm94eS5ocmVmKTtjb25zdCBuPSh0aGlzLnByb3h5Lmhvc3RuYW1lfHx0aGlzLnByb3h5Lmhvc3QpLnJlcGxhY2UoL15cW3xcXSQvZywiIikscj10aGlzLnByb3h5LnBvcnQ/cGFyc2VJbnQodGhpcy5wcm94eS5wb3J0LDEwKToiaHR0cHM6Ij09PXRoaXMucHJveHkucHJvdG9jb2w/NDQzOjgwO3RoaXMuY29ubmVjdE9wdHM9e0FMUE5Qcm90b2NvbHM6WyJodHRwLzEuMSJdLC4uLmU/cmUoZSwiaGVhZGVycyIpOm51bGwsaG9zdDpuLHBvcnQ6cn19YXN5bmMgY29ubmVjdCh0LGUpe2NvbnN0e3Byb3h5Om59PXRoaXM7aWYoIWUuaG9zdCl0aHJvdyBuZXcgVHlwZUVycm9yKCdObyAiaG9zdCIgcHJvdmlkZWQnKTtsZXQgcjtpZigiaHR0cHM6Ij09PW4ucHJvdG9jb2wpe3RlKCJDcmVhdGluZyBgdGxzLlNvY2tldGA6ICVvIix0aGlzLmNvbm5lY3RPcHRzKTtjb25zdCB0PXRoaXMuY29ubmVjdE9wdHMuc2VydmVybmFtZXx8dGhpcy5jb25uZWN0T3B0cy5ob3N0O3I9Zi5jb25uZWN0KHsuLi50aGlzLmNvbm5lY3RPcHRzLHNlcnZlcm5hbWU6dCYmYS5pc0lQKHQpP3ZvaWQgMDp0fSl9ZWxzZSB0ZSgiQ3JlYXRpbmcgYG5ldC5Tb2NrZXRgOiAlbyIsdGhpcy5jb25uZWN0T3B0cykscj1hLmNvbm5lY3QodGhpcy5jb25uZWN0T3B0cyk7Y29uc3Qgbz0iZnVuY3Rpb24iPT10eXBlb2YgdGhpcy5wcm94eUhlYWRlcnM/dGhpcy5wcm94eUhlYWRlcnMoKTp7Li4udGhpcy5wcm94eUhlYWRlcnN9LHM9YS5pc0lQdjYoZS5ob3N0KT9gWyR7ZS5ob3N0fV1gOmUuaG9zdDtsZXQgaT1gQ09OTkVDVCAke3N9OiR7ZS5wb3J0fSBIVFRQLzEuMVxyXG5gO2lmKG4udXNlcm5hbWV8fG4ucGFzc3dvcmQpe2NvbnN0IHQ9YCR7ZGVjb2RlVVJJQ29tcG9uZW50KG4udXNlcm5hbWUpfToke2RlY29kZVVSSUNvbXBvbmVudChuLnBhc3N3b3JkKX1gO29bIlByb3h5LUF1dGhvcml6YXRpb24iXT1gQmFzaWMgJHtCdWZmZXIuZnJvbSh0KS50b1N0cmluZygiYmFzZTY0Iil9YH1vLkhvc3Q9YCR7c306JHtlLnBvcnR9YCxvWyJQcm94eS1Db25uZWN0aW9uIl18fChvWyJQcm94eS1Db25uZWN0aW9uIl09dGhpcy5rZWVwQWxpdmU/IktlZXAtQWxpdmUiOiJjbG9zZSIpO2Zvcihjb25zdCB0IG9mIE9iamVjdC5rZXlzKG8pKWkrPWAke3R9OiAke29bdF19XHJcbmA7Y29uc3QgYz1YdChyKTtyLndyaXRlKGAke2l9XHJcbmApO2NvbnN0e2Nvbm5lY3Q6dSxidWZmZXJlZDpofT1hd2FpdCBjO2lmKHQuZW1pdCgicHJveHlDb25uZWN0Iix1KSx0aGlzLmVtaXQoInByb3h5Q29ubmVjdCIsdSx0KSwyMDA9PT11LnN0YXR1c0NvZGUpe2lmKHQub25jZSgic29ja2V0IixuZSksZS5zZWN1cmVFbmRwb2ludCl7dGUoIlVwZ3JhZGluZyBzb2NrZXQgY29ubmVjdGlvbiB0byBUTFMiKTtjb25zdCB0PWUuc2VydmVybmFtZXx8ZS5ob3N0O3JldHVybiBmLmNvbm5lY3Qoey4uLnJlKGUsImhvc3QiLCJwYXRoIiwicG9ydCIpLHNvY2tldDpyLHNlcnZlcm5hbWU6YS5pc0lQKHQpP3ZvaWQgMDp0fSl9cmV0dXJuIHJ9ci5kZXN0cm95KCk7Y29uc3QgcD1uZXcgYS5Tb2NrZXQoe3dyaXRhYmxlOiExfSk7cmV0dXJuIHAucmVhZGFibGU9ITAsdC5vbmNlKCJzb2NrZXQiLCh0PT57dGUoIlJlcGxheWluZyBwcm94eSBidWZmZXIgZm9yIGZhaWxlZCByZXF1ZXN0IiksdC5wdXNoKGgpLHQucHVzaChudWxsKX0pKSxwfX1mdW5jdGlvbiBuZSh0KXt0LnJlc3VtZSgpfWZ1bmN0aW9uIHJlKHQsLi4uZSl7Y29uc3Qgbj17fTtsZXQgcjtmb3IociBpbiB0KWUuaW5jbHVkZXMocil8fChuW3JdPXRbcl0pO3JldHVybiBufWNvbnN0IG9lPTMyNzY4O2Z1bmN0aW9uIHNlKHQpe3JldHVybiB0LnJlcGxhY2UoL15bQS1aXTovLCIiKS5yZXBsYWNlKC9cXC9nLCIvIil9Y29uc3QgaWU9bjtsZXQgY2UsdWU9ITE7ZnVuY3Rpb24gYWUodCl7aWUuZGVidWcmJmNvbnNvbGUubG9nKGBbQU5SIFdvcmtlcl0gJHt0fWApfXZhciBmZSxoZSxwZTtjb25zdCBsZT1mdW5jdGlvbih0KXtsZXQgZTt0cnl7ZT1uZXcgVVJMKHQudXJsKX1jYXRjaChlKXtyZXR1cm4geCgoKCk9Pntjb25zb2xlLndhcm4oIltAc2VudHJ5L25vZGVdOiBJbnZhbGlkIGRzbiBvciB0dW5uZWwgb3B0aW9uLCB3aWxsIG5vdCBzZW5kIGFueSBldmVudHMuIFRoZSB0dW5uZWwgb3B0aW9uIG11c3QgYmUgYSBmdWxsIFVSTCB3aGVuIHVzZWQuIil9KSksRnQodCwoKCk9PlByb21pc2UucmVzb2x2ZSh7fSkpKX1jb25zdCBuPSJodHRwczoiPT09ZS5wcm90b2NvbCxyPWZ1bmN0aW9uKHQsZSl7Y29uc3R7bm9fcHJveHk6bn09cHJvY2Vzcy5lbnY7cmV0dXJuIG4mJm4uc3BsaXQoIiwiKS5zb21lKChlPT50Lmhvc3QuZW5kc1dpdGgoZSl8fHQuaG9zdG5hbWUuZW5kc1dpdGgoZSkpKT92b2lkIDA6ZX0oZSx0LnByb3h5fHwobj9wcm9jZXNzLmVudi5odHRwc19wcm94eTp2b2lkIDApfHxwcm9jZXNzLmVudi5odHRwX3Byb3h5KSxvPW4/aTpzLGE9dm9pZCAwIT09dC5rZWVwQWxpdmUmJnQua2VlcEFsaXZlLGY9cj9uZXcgZWUocik6bmV3IG8uQWdlbnQoe2tlZXBBbGl2ZTphLG1heFNvY2tldHM6MzAsdGltZW91dDoyZTN9KTtyZXR1cm4genQoKCgpPT57Y29uc3QgZT1mdW5jdGlvbih0LGUsbil7Y29uc3R7aG9zdG5hbWU6cixwYXRobmFtZTpvLHBvcnQ6cyxwcm90b2NvbDppLHNlYXJjaDphfT1uZXcgVVJMKHQudXJsKTtyZXR1cm4gZnVuY3Rpb24oZil7cmV0dXJuIG5ldyBQcm9taXNlKCgoaCxwKT0+e2xldCBsPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgYyh7cmVhZCgpe3RoaXMucHVzaCh0KSx0aGlzLnB1c2gobnVsbCl9fSl9KGYuYm9keSk7Y29uc3QgZD17Li4udC5oZWFkZXJzfTtmLmJvZHkubGVuZ3RoPm9lJiYoZFsiY29udGVudC1lbmNvZGluZyJdPSJnemlwIixsPWwucGlwZSh1KCkpKTtjb25zdCBtPWUucmVxdWVzdCh7bWV0aG9kOiJQT1NUIixhZ2VudDpuLGhlYWRlcnM6ZCxob3N0bmFtZTpyLHBhdGg6YCR7b30ke2F9YCxwb3J0OnMscHJvdG9jb2w6aSxjYTp0LmNhQ2VydHN9LCh0PT57dC5vbigiZGF0YSIsKCgpPT57fSkpLHQub24oImVuZCIsKCgpPT57fSkpLHQuc2V0RW5jb2RpbmcoInV0ZjgiKTtjb25zdCBlPXQuaGVhZGVyc1sicmV0cnktYWZ0ZXIiXT8/bnVsbCxuPXQuaGVhZGVyc1sieC1zZW50cnktcmF0ZS1saW1pdHMiXT8/bnVsbDtoKHtzdGF0dXNDb2RlOnQuc3RhdHVzQ29kZSxoZWFkZXJzOnsicmV0cnktYWZ0ZXIiOmUsIngtc2VudHJ5LXJhdGUtbGltaXRzIjpBcnJheS5pc0FycmF5KG4pP25bMF06bn19KX0pKTttLm9uKCJlcnJvciIscCksbC5waXBlKG0pfSkpfX0odCx0Lmh0dHBNb2R1bGU/P28sZik7cmV0dXJuIEZ0KHQsZSl9KSl9KHt1cmw6KGZlPWllLmRzbixoZT1pZS50dW5uZWwscGU9aWUuc2RrTWV0YWRhdGEuc2RrLGhlfHxgJHtmdW5jdGlvbih0KXtyZXR1cm5gJHtmdW5jdGlvbih0KXtjb25zdCBlPXQucHJvdG9jb2w/YCR7dC5wcm90b2NvbH06YDoiIixuPXQucG9ydD9gOiR7dC5wb3J0fWA6IiI7cmV0dXJuYCR7ZX0vLyR7dC5ob3N0fSR7bn0ke3QucGF0aD9gLyR7dC5wYXRofWA6IiJ9L2FwaS9gfSh0KX0ke3QucHJvamVjdElkfS9lbnZlbG9wZS9gfShmZSl9PyR7WXQoZmUscGUpfWApLHJlY29yZERyb3BwZWRFdmVudDooKT0+e319KTthc3luYyBmdW5jdGlvbiBkZSgpe2lmKGNlKXthZSgiU2VuZGluZyBhYm5vcm1hbCBzZXNzaW9uIiksaHQoY2Use3N0YXR1czoiYWJub3JtYWwiLGFibm9ybWFsX21lY2hhbmlzbToiYW5yX2ZvcmVncm91bmQifSk7Y29uc3QgdD1mdW5jdGlvbih0LGUsbixyKXtjb25zdCBvPW90KG4pO3JldHVybiBRKHtzZW50X2F0OihuZXcgRGF0ZSkudG9JU09TdHJpbmcoKSwuLi5vJiZ7c2RrOm99LC4uLiEhciYmZSYme2RzbjprKGUpfX0sWyJhZ2dyZWdhdGVzImluIHQ/W3t0eXBlOiJzZXNzaW9ucyJ9LHRdOlt7dHlwZToic2Vzc2lvbiJ9LHQudG9KU09OKCldXSl9KGNlLGllLmRzbixpZS5zZGtNZXRhZGF0YSxpZS50dW5uZWwpO2FlKEpTT04uc3RyaW5naWZ5KHQpKSxhd2FpdCBsZS5zZW5kKHQpO3RyeXtlPy5wb3N0TWVzc2FnZSgic2Vzc2lvbi1lbmRlZCIpfWNhdGNoKHQpe319fWZ1bmN0aW9uIG1lKHQpe2lmKCF0KXJldHVybjtjb25zdCBlPWZ1bmN0aW9uKHQpe2lmKCF0Lmxlbmd0aClyZXR1cm5bXTtjb25zdCBlPUFycmF5LmZyb20odCk7cmV0dXJuL3NlbnRyeVdyYXBwZWQvLnRlc3QoZVtlLmxlbmd0aC0xXS5mdW5jdGlvbnx8IiIpJiZlLnBvcCgpLGUucmV2ZXJzZSgpLFAudGVzdChlW2UubGVuZ3RoLTFdLmZ1bmN0aW9ufHwiIikmJihlLnBvcCgpLFAudGVzdChlW2UubGVuZ3RoLTFdLmZ1bmN0aW9ufHwiIikmJmUucG9wKCkpLGUuc2xpY2UoMCxBKS5tYXAoKHQ9Pih7Li4udCxmaWxlbmFtZTp0LmZpbGVuYW1lfHxlW2UubGVuZ3RoLTFdLmZpbGVuYW1lLGZ1bmN0aW9uOnQuZnVuY3Rpb258fEl9KSkpfSh0KTtpZihpZS5hcHBSb290UGF0aClmb3IoY29uc3QgdCBvZiBlKXQuZmlsZW5hbWUmJih0LmZpbGVuYW1lPUcodC5maWxlbmFtZSxpZS5hcHBSb290UGF0aCkpO3JldHVybiBlfWFzeW5jIGZ1bmN0aW9uIGdlKHQsZSl7aWYodWUpcmV0dXJuO3VlPSEwLGF3YWl0IGRlKCksYWUoIlNlbmRpbmcgZXZlbnQiKTtjb25zdCBuPXtldmVudF9pZDpNKCksY29udGV4dHM6aWUuY29udGV4dHMscmVsZWFzZTppZS5yZWxlYXNlLGVudmlyb25tZW50OmllLmVudmlyb25tZW50LGRpc3Q6aWUuZGlzdCxwbGF0Zm9ybToibm9kZSIsbGV2ZWw6ImVycm9yIixleGNlcHRpb246e3ZhbHVlczpbe3R5cGU6IkFwcGxpY2F0aW9uTm90UmVzcG9uZGluZyIsdmFsdWU6YEFwcGxpY2F0aW9uIE5vdCBSZXNwb25kaW5nIGZvciBhdCBsZWFzdCAke2llLmFuclRocmVzaG9sZH0gbXNgLHN0YWNrdHJhY2U6e2ZyYW1lczptZSh0KX0sbWVjaGFuaXNtOnt0eXBlOiJBTlIifX1dfSx0YWdzOmllLnN0YXRpY1RhZ3N9O2UmJmZ1bmN0aW9uKHQsZSl7aWYoSHQodCxlKSwhdC5jb250ZXh0cz8udHJhY2Upe2NvbnN0e3RyYWNlSWQ6bixzcGFuSWQ6cixwYXJlbnRTcGFuSWQ6b309ZS5wcm9wYWdhdGlvbkNvbnRleHQ7dC5jb250ZXh0cz17dHJhY2U6e3RyYWNlX2lkOm4sc3Bhbl9pZDpyLHBhcmVudF9zcGFuX2lkOm99LC4uLnQuY29udGV4dHN9fX0obixlKTtjb25zdCByPUd0KG4saWUuZHNuLGllLnNka01ldGFkYXRhLGllLnR1bm5lbCk7YWUoSlNPTi5zdHJpbmdpZnkocikpLGF3YWl0IGxlLnNlbmQociksYXdhaXQgbGUuZmx1c2goMmUzKSxzZXRUaW1lb3V0KCgoKT0+e3Byb2Nlc3MuZXhpdCgwKX0pLDVlMyl9bGV0IHllO2lmKGFlKCJTdGFydGVkIiksaWUuY2FwdHVyZVN0YWNrVHJhY2Upe2FlKCJDb25uZWN0aW5nIHRvIGRlYnVnZ2VyIik7Y29uc3QgZT1uZXcgdDtlLmNvbm5lY3RUb01haW5UaHJlYWQoKSxhZSgiQ29ubmVjdGVkIHRvIGRlYnVnZ2VyIik7Y29uc3Qgbj1uZXcgTWFwO2Uub24oIkRlYnVnZ2VyLnNjcmlwdFBhcnNlZCIsKHQ9PntuLnNldCh0LnBhcmFtcy5zY3JpcHRJZCx0LnBhcmFtcy51cmwpfSkpLGUub24oIkRlYnVnZ2VyLnBhdXNlZCIsKHQ9PntpZigib3RoZXIiPT09dC5wYXJhbXMucmVhc29uKXRyeXthZSgiRGVidWdnZXIgcGF1c2VkIik7Y29uc3Qgcz1bLi4udC5wYXJhbXMuY2FsbEZyYW1lc10saT1pZS5hcHBSb290UGF0aD9mdW5jdGlvbih0PShwcm9jZXNzLmFyZ3ZbMV0/eihwcm9jZXNzLmFyZ3ZbMV0pOnByb2Nlc3MuY3dkKCkpLGU9IlxcIj09PW8pe2NvbnN0IG49ZT9zZSh0KTp0O3JldHVybiB0PT57aWYoIXQpcmV0dXJuO2NvbnN0IG89ZT9zZSh0KTp0O2xldHtkaXI6cyxiYXNlOmksZXh0OmN9PXIucGFyc2Uobyk7Ii5qcyIhPT1jJiYiLm1qcyIhPT1jJiYiLmNqcyIhPT1jfHwoaT1pLnNsaWNlKDAsLTEqYy5sZW5ndGgpKSxzfHwocz0iLiIpO2NvbnN0IHU9cy5sYXN0SW5kZXhPZigiL25vZGVfbW9kdWxlcyIpO2lmKHU+LTEpcmV0dXJuYCR7cy5zbGljZSh1KzE0KS5yZXBsYWNlKC9cLy9nLCIuIil9OiR7aX1gO2lmKHMuc3RhcnRzV2l0aChuKSl7bGV0IHQ9cy5zbGljZShuLmxlbmd0aCsxKS5yZXBsYWNlKC9cLy9nLCIuIik7cmV0dXJuIHQmJih0Kz0iOiIpLHQrPWksdH1yZXR1cm4gaX19KGllLmFwcFJvb3RQYXRoKTooKT0+e30sYz1zLm1hcCgodD0+ZnVuY3Rpb24odCxlLG4pe2NvbnN0IHI9ZT9lLnJlcGxhY2UoL15maWxlOlwvXC8vLCIiKTp2b2lkIDAsbz10LmxvY2F0aW9uLmNvbHVtbk51bWJlcj90LmxvY2F0aW9uLmNvbHVtbk51bWJlcisxOnZvaWQgMCxzPXQubG9jYXRpb24ubGluZU51bWJlcj90LmxvY2F0aW9uLmxpbmVOdW1iZXIrMTp2b2lkIDA7cmV0dXJuIGooe2ZpbGVuYW1lOnIsbW9kdWxlOm4ociksZnVuY3Rpb246dC5mdW5jdGlvbk5hbWV8fEksY29sbm86byxsaW5lbm86cyxpbl9hcHA6cj9GKHIpOnZvaWQgMH0pfSh0LG4uZ2V0KHQubG9jYXRpb24uc2NyaXB0SWQpLGkpKSksdT1zZXRUaW1lb3V0KCgoKT0+e2dlKGMpLnRoZW4obnVsbCwoKCk9PnthZSgiU2VuZGluZyBBTlIgZXZlbnQgZmFpbGVkLiIpfSkpfSksNWUzKTtlLnBvc3QoIlJ1bnRpbWUuZXZhbHVhdGUiLHtleHByZXNzaW9uOiJnbG9iYWwuX19TRU5UUllfR0VUX1NDT1BFU19fKCk7IixzaWxlbnQ6ITAscmV0dXJuQnlWYWx1ZTohMH0sKCh0LG4pPT57dCYmYWUoYEVycm9yIGV4ZWN1dGluZyBzY3JpcHQ6ICcke3QubWVzc2FnZX0nYCksY2xlYXJUaW1lb3V0KHUpO2NvbnN0IHI9biYmbi5yZXN1bHQ/bi5yZXN1bHQudmFsdWU6dm9pZCAwO2UucG9zdCgiRGVidWdnZXIucmVzdW1lIiksZS5wb3N0KCJEZWJ1Z2dlci5kaXNhYmxlIiksZ2UoYyxyKS50aGVuKG51bGwsKCgpPT57YWUoIlNlbmRpbmcgQU5SIGV2ZW50IGZhaWxlZC4iKX0pKX0pKX1jYXRjaCh0KXt0aHJvdyBlLnBvc3QoIkRlYnVnZ2VyLnJlc3VtZSIpLGUucG9zdCgiRGVidWdnZXIuZGlzYWJsZSIpLHR9fSkpLHllPSgpPT57dHJ5e2UucG9zdCgiRGVidWdnZXIuZW5hYmxlIiwoKCk9PntlLnBvc3QoIkRlYnVnZ2VyLnBhdXNlIil9KSl9Y2F0Y2godCl7fX19Y29uc3R7cG9sbDpiZX09ZnVuY3Rpb24odCxlLG4scil7Y29uc3Qgbz10KCk7bGV0IHM9ITEsaT0hMDtyZXR1cm4gc2V0SW50ZXJ2YWwoKCgpPT57Y29uc3QgdD1vLmdldFRpbWVNcygpOyExPT09cyYmdD5lK24mJihzPSEwLGkmJnIoKSksdDxlK24mJihzPSExKX0pLDIwKSx7cG9sbDooKT0+e28ucmVzZXQoKX0sZW5hYmxlZDp0PT57aT10fX19KChmdW5jdGlvbigpe2xldCB0PXByb2Nlc3MuaHJ0aW1lKCk7cmV0dXJue2dldFRpbWVNczooKT0+e2NvbnN0W2Usbl09cHJvY2Vzcy5ocnRpbWUodCk7cmV0dXJuIE1hdGguZmxvb3IoMWUzKmUrbi8xZTYpfSxyZXNldDooKT0+e3Q9cHJvY2Vzcy5ocnRpbWUoKX19fSksaWUucG9sbEludGVydmFsLGllLmFuclRocmVzaG9sZCwoZnVuY3Rpb24oKXthZSgiV2F0Y2hkb2cgdGltZW91dCIpLHllPyhhZSgiUGF1c2luZyBkZWJ1Z2dlciB0byBjYXB0dXJlIHN0YWNrIHRyYWNlIikseWUoKSk6KGFlKCJDYXB0dXJpbmcgZXZlbnQgd2l0aG91dCBhIHN0YWNrIHRyYWNlIiksZ2UoKS50aGVuKG51bGwsKCgpPT57YWUoIlNlbmRpbmcgQU5SIGV2ZW50IGZhaWxlZCBvbiB3YXRjaGRvZyB0aW1lb3V0LiIpfSkpKX0pKTtlPy5vbigibWVzc2FnZSIsKHQ9Pnt0LnNlc3Npb24mJihjZT1mdCh0LnNlc3Npb24pKSxiZSgpfSkpOw==';

const DEFAULT_INTERVAL = 50;
const DEFAULT_HANG_THRESHOLD = 5000;

function log(message, ...args) {
  logger.log(`[ANR] ${message}`, ...args);
}

function globalWithScopeFetchFn() {
  return GLOBAL_OBJ;
}

/** Fetches merged scope data */
function getScopeData() {
  const scope = getGlobalScope().getScopeData();
  mergeScopeData(scope, getIsolationScope().getScopeData());
  mergeScopeData(scope, getCurrentScope().getScopeData());

  // We remove attachments because they likely won't serialize well as json
  scope.attachments = [];
  // We can't serialize event processor functions
  scope.eventProcessors = [];

  return scope;
}

/**
 * Gets contexts by calling all event processors. This shouldn't be called until all integrations are setup
 */
async function getContexts(client) {
  let event = { message: 'ANR' };
  const eventHint = {};

  for (const processor of client.getEventProcessors()) {
    if (event === null) break;
    event = await processor(event, eventHint);
  }

  return _optionalChain$9([event, 'optionalAccess', _2 => _2.contexts]) || {};
}

const INTEGRATION_NAME$1 = 'Anr';

const _anrIntegration = ((options = {}) => {
  if (NODE_VERSION.major < 16 || (NODE_VERSION.major === 16 && NODE_VERSION.minor < 17)) {
    throw new Error('ANR detection requires Node 16.17.0 or later');
  }

  let worker;
  let client;

  // Hookup the scope fetch function to the global object so that it can be called from the worker thread via the
  // debugger when it pauses
  const gbl = globalWithScopeFetchFn();
  gbl.__SENTRY_GET_SCOPES__ = getScopeData;

  return {
    name: INTEGRATION_NAME$1,
    startWorker: () => {
      if (worker) {
        return;
      }

      if (client) {
        worker = _startWorker(client, options);
      }
    },
    stopWorker: () => {
      if (worker) {
        // eslint-disable-next-line @typescript-eslint/no-floating-promises
        worker.then(stop => {
          stop();
          worker = undefined;
        });
      }
    },
    setup(initClient) {
      client = initClient;

      // setImmediate is used to ensure that all other integrations have had their setup called first.
      // This allows us to call into all integrations to fetch the full context
      setImmediate(() => this.startWorker());
    },
  } ;
}) ;

const anrIntegration = defineIntegration(_anrIntegration) ;

/**
 * Starts the ANR worker thread
 *
 * @returns A function to stop the worker
 */
async function _startWorker(
  client,
  integrationOptions,
) {
  const dsn = client.getDsn();

  if (!dsn) {
    return () => {
      //
    };
  }

  const contexts = await getContexts(client);

  // These will not be accurate if sent later from the worker thread
   _optionalChainDelete([contexts, 'access', _3 => _3.app, 'optionalAccess', _4 => delete _4.app_memory]);
   _optionalChainDelete([contexts, 'access', _5 => _5.device, 'optionalAccess', _6 => delete _6.free_memory]);

  const initOptions = client.getOptions();

  const sdkMetadata = client.getSdkMetadata() || {};
  if (sdkMetadata.sdk) {
    sdkMetadata.sdk.integrations = initOptions.integrations.map(i => i.name);
  }

  const options = {
    debug: logger.isEnabled(),
    dsn,
    tunnel: initOptions.tunnel,
    environment: initOptions.environment || 'production',
    release: initOptions.release,
    dist: initOptions.dist,
    sdkMetadata,
    appRootPath: integrationOptions.appRootPath,
    pollInterval: integrationOptions.pollInterval || DEFAULT_INTERVAL,
    anrThreshold: integrationOptions.anrThreshold || DEFAULT_HANG_THRESHOLD,
    captureStackTrace: !!integrationOptions.captureStackTrace,
    staticTags: integrationOptions.staticTags || {},
    contexts,
  };

  if (options.captureStackTrace) {
    if (!inspector.url()) {
      inspector.open(0);
    }
  }

  const worker = new Worker(new URL(`data:application/javascript;base64,${base64WorkerScript}`), {
    workerData: options,
    // We don't want any Node args to be passed to the worker
    execArgv: [],
  });

  process.on('exit', () => {
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    worker.terminate();
  });

  const timer = setInterval(() => {
    try {
      const currentSession = getCurrentScope().getSession();
      // We need to copy the session object and remove the toJSON method so it can be sent to the worker
      // serialized without making it a SerializedSession
      const session = currentSession ? { ...currentSession, toJSON: undefined } : undefined;
      // message the worker to tell it the main event loop is still running
      worker.postMessage({ session });
    } catch (_) {
      //
    }
  }, options.pollInterval);
  // Timer should not block exit
  timer.unref();

  worker.on('message', (msg) => {
    if (msg === 'session-ended') {
      log('ANR event sent from ANR worker. Clearing session in this thread.');
      getCurrentScope().setSession(undefined);
    }
  });

  worker.once('error', (err) => {
    clearInterval(timer);
    log('ANR worker error', err);
  });

  worker.once('exit', (code) => {
    clearInterval(timer);
    log('ANR worker exit', code);
  });

  // Ensure this thread can't block app exit
  worker.unref();

  return () => {
    // eslint-disable-next-line @typescript-eslint/no-floating-promises
    worker.terminate();
    clearInterval(timer);
  };
}

function _optionalChain$8(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

const _expressIntegration = (() => {
  return {
    name: 'Express',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        new ExpressInstrumentation({
          requestHook(span) {
            addOriginToSpan(span, 'auto.http.otel.express');
          },
          spanNameHook(info, defaultName) {
            if (getIsolationScope() === getDefaultIsolationScope()) {
              DEBUG_BUILD &&
                logger.warn('Isolation scope is still default isolation scope - skipping setting transactionName');
              return defaultName;
            }
            if (info.layerType === 'request_handler') {
              // type cast b/c Otel unfortunately types info.request as any :(
              const req = info.request ;
              const method = req.method ? req.method.toUpperCase() : 'GET';
              getIsolationScope().setTransactionName(`${method} ${info.route}`);
            }
            return defaultName;
          },
        }),
      );
    },
  };
}) ;

/**
 * Express integration
 *
 * Capture tracing data for express.
 * In order to capture exceptions, you have to call `setupExpressErrorHandler(app)` before any other middleware and after all controllers.
 */
const expressIntegration = defineIntegration(_expressIntegration);

/**
 * An Express-compatible error handler.
 */
function expressErrorHandler(options

) {
  return function sentryErrorMiddleware(
    error,
    _req,
    res,
    next,
  ) {
    const shouldHandleError = _optionalChain$8([options, 'optionalAccess', _ => _.shouldHandleError]) || defaultShouldHandleError;

    if (shouldHandleError(error)) {
      const client = getClient$1();
      if (client && client.getOptions().autoSessionTracking) {
        // Check if the `SessionFlusher` is instantiated on the client to go into this branch that marks the
        // `requestSession.status` as `Crashed`, and this check is necessary because the `SessionFlusher` is only
        // instantiated when the the`requestHandler` middleware is initialised, which indicates that we should be
        // running in SessionAggregates mode
        const isSessionAggregatesMode = client['_sessionFlusher'] !== undefined;
        if (isSessionAggregatesMode) {
          const requestSession = getIsolationScope().getRequestSession();
          // If an error bubbles to the `errorHandler`, then this is an unhandled error, and should be reported as a
          // Crashed session. The `_requestSession.status` is checked to ensure that this error is happening within
          // the bounds of a request, and if so the status is updated
          if (requestSession && requestSession.status !== undefined) {
            requestSession.status = 'crashed';
          }
        }
      }

      const eventId = captureException(error, { mechanism: { type: 'middleware', handled: false } });
      (res ).sentry = eventId;
      next(error);

      return;
    }

    next(error);
  };
}

/**
 * Setup an error handler for Express.
 * The error handler must be before any other middleware and after all controllers.
 */
function setupExpressErrorHandler(app) {
  app.use(expressErrorHandler());

  if (!isWrapped$1(app.use)) {
    consoleSandbox(() => {
      // eslint-disable-next-line no-console
      console.warn(
        '[Sentry] Express is not instrumented. This is likely because you required/imported express before calling `Sentry.init()`.',
      );
    });
  }
}

function getStatusCodeFromResponse(error) {
  const statusCode = error.status || error.statusCode || error.status_code || (error.output && error.output.statusCode);
  return statusCode ? parseInt(statusCode , 10) : 500;
}

/** Returns true if response code is internal server error */
function defaultShouldHandleError(error) {
  const status = getStatusCodeFromResponse(error);
  return status >= 500;
}

function _optionalChain$7(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
const _fastifyIntegration = (() => {
  return {
    name: 'Fastify',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        new FastifyInstrumentation({
          requestHook(span) {
            addOriginToSpan(span, 'auto.http.otel.fastify');
          },
        }),
      );
    },
  };
}) ;

/**
 * Express integration
 *
 * Capture tracing data for fastify.
 */
const fastifyIntegration = defineIntegration(_fastifyIntegration);

// We inline the types we care about here

/**
 * Setup an error handler for Fastify.
 */
function setupFastifyErrorHandler(fastify) {
  const plugin = Object.assign(
    function (fastify, _options, done) {
      fastify.addHook('onError', async (_request, _reply, error) => {
        captureException(error);
      });

      // registering `onRequest` hook here instead of using Otel `onRequest` callback b/c `onRequest` hook
      // is ironically called in the fastify `preHandler` hook which is called later in the lifecycle:
      // https://fastify.dev/docs/latest/Reference/Lifecycle/
      fastify.addHook('onRequest', async (request, _reply) => {
        const reqWithRouteInfo = request ;

        // Taken from Otel Fastify instrumentation:
        // https://github.com/open-telemetry/opentelemetry-js-contrib/blob/main/plugins/node/opentelemetry-instrumentation-fastify/src/instrumentation.ts#L94-L96
        const routeName = _optionalChain$7([reqWithRouteInfo, 'access', _ => _.routeOptions, 'optionalAccess', _2 => _2.url]) || reqWithRouteInfo.routerPath;
        const method = _optionalChain$7([reqWithRouteInfo, 'access', _3 => _3.routeOptions, 'optionalAccess', _4 => _4.method]) || 'GET';

        getIsolationScope().setTransactionName(`${method} ${routeName}`);
      });

      done();
    },
    {
      [Symbol.for('skip-override')]: true,
      [Symbol.for('fastify.display-name')]: 'sentry-fastify-error-handler',
    },
  );

  fastify.register(plugin);

  if (!isWrapped$1(fastify.addHook)) {
    consoleSandbox(() => {
      // eslint-disable-next-line no-console
      console.warn(
        '[Sentry] Fastify is not instrumented. This is likely because you required/imported fastify before calling `Sentry.init()`.',
      );
    });
  }
}

const _graphqlIntegration = (() => {
  return {
    name: 'Graphql',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        new GraphQLInstrumentation({
          ignoreTrivialResolveSpans: true,
          responseHook(span) {
            addOriginToSpan(span, 'auto.graphql.otel.graphql');
          },
        }),
      );
    },
  };
}) ;

/**
 * GraphQL integration
 *
 * Capture tracing data for GraphQL.
 */
const graphqlIntegration = defineIntegration(_graphqlIntegration);

const _mongoIntegration = (() => {
  return {
    name: 'Mongo',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        new MongoDBInstrumentation({
          responseHook(span) {
            addOriginToSpan(span, 'auto.db.otel.mongo');
          },
        }),
      );
    },
  };
}) ;

/**
 * MongoDB integration
 *
 * Capture tracing data for MongoDB.
 */
const mongoIntegration = defineIntegration(_mongoIntegration);

const _mongooseIntegration = (() => {
  return {
    name: 'Mongoose',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        new MongooseInstrumentation({
          responseHook(span) {
            addOriginToSpan(span, 'auto.db.otel.mongoose');
          },
        }),
      );
    },
  };
}) ;

/**
 * Mongoose integration
 *
 * Capture tracing data for Mongoose.
 */
const mongooseIntegration = defineIntegration(_mongooseIntegration);

const _mysqlIntegration = (() => {
  return {
    name: 'Mysql',
    setupOnce() {
      addOpenTelemetryInstrumentation(new MySQLInstrumentation({}));
    },
  };
}) ;

/**
 * MySQL integration
 *
 * Capture tracing data for mysql.
 */
const mysqlIntegration = defineIntegration(_mysqlIntegration);

const _mysql2Integration = (() => {
  return {
    name: 'Mysql2',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        new MySQL2Instrumentation({
          responseHook(span) {
            addOriginToSpan(span, 'auto.db.otel.mysql2');
          },
        }),
      );
    },
  };
}) ;

/**
 * MySQL2 integration
 *
 * Capture tracing data for mysql2
 */
const mysql2Integration = defineIntegration(_mysql2Integration);

const _redisIntegration = (() => {
  return {
    name: 'Redis',
    setupOnce() {
      addOpenTelemetryInstrumentation([
        new IORedisInstrumentation({}),
        // todo: implement them gradually
        // new LegacyRedisInstrumentation({}),
        // new RedisInstrumentation({}),
      ]);
    },
  };
}) ;

/**
 * Redis integration for "ioredis"
 *
 * Capture tracing data for redis and ioredis.
 */
const redisIntegration = defineIntegration(_redisIntegration);

function _optionalChain$6(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
const _nestIntegration = (() => {
  return {
    name: 'Nest',
    setupOnce() {
      addOpenTelemetryInstrumentation(new NestInstrumentation({}));
    },
  };
}) ;

/**
 * Nest framework integration
 *
 * Capture tracing data for nest.
 */
const nestIntegration = defineIntegration(_nestIntegration);

/**
 * Setup an error handler for Nest.
 */
function setupNestErrorHandler(app, baseFilter) {
  app.useGlobalInterceptors({
    intercept(context, next) {
      if (getIsolationScope() === getDefaultIsolationScope()) {
        logger.warn('Isolation scope is still the default isolation scope, skipping setting transactionName.');
        return next.handle();
      }

      if (context.getType() === 'http') {
        const req = context.switchToHttp().getRequest();
        if (req.route) {
          getIsolationScope().setTransactionName(`${_optionalChain$6([req, 'access', _ => _.method, 'optionalAccess', _2 => _2.toUpperCase, 'call', _3 => _3()]) || 'GET'} ${req.route.path}`);
        }
      }

      return next.handle();
    },
  });

  const wrappedFilter = new Proxy(baseFilter, {
    get(target, prop, receiver) {
      if (prop === 'catch') {
        const originalCatch = Reflect.get(target, prop, receiver);

        return (exception, host) => {
          captureException(exception);
          return originalCatch.apply(target, [exception, host]);
        };
      }
      return Reflect.get(target, prop, receiver);
    },
  });

  app.useGlobalFilters(wrappedFilter);
}

const _postgresIntegration = (() => {
  return {
    name: 'Postgres',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        new PgInstrumentation({
          requireParentSpan: true,
          requestHook(span) {
            addOriginToSpan(span, 'auto.db.otel.postgres');
          },
        }),
      );
    },
  };
}) ;

/**
 * Postgres integration
 *
 * Capture tracing data for pg.
 */
const postgresIntegration = defineIntegration(_postgresIntegration);

function _optionalChain$5(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }// When importing CJS modules into an ESM module, we cannot import the named exports directly.

const _prismaIntegration = (() => {
  return {
    name: 'Prisma',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        // does not have a hook to adjust spans & add origin
        new prismaInstrumentation.PrismaInstrumentation({}),
      );
    },

    setup(client) {
      client.on('spanStart', span => {
        const spanJSON = spanToJSON(span);
        if (_optionalChain$5([spanJSON, 'access', _ => _.description, 'optionalAccess', _2 => _2.startsWith, 'call', _3 => _3('prisma:')])) {
          span.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN, 'auto.db.otel.prisma');
        }

        if (spanJSON.description === 'prisma:engine:db_query') {
          span.setAttribute('db.system', 'prisma');
        }
      });
    },
  };
}) ;

/**
 * Prisma integration
 *
 * Capture tracing data for prisma.
 * Note: This requieres to set:
 * previewFeatures = ["tracing"]
 * For the prisma client.
 * See https://www.prisma.io/docs/concepts/components/prisma-client/opentelemetry-tracing for more details.
 */
const prismaIntegration = defineIntegration(_prismaIntegration);

function _optionalChain$4(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
const _hapiIntegration = (() => {
  return {
    name: 'Hapi',
    setupOnce() {
      addOpenTelemetryInstrumentation(new HapiInstrumentation());
    },
  };
}) ;

/**
 * Hapi integration
 *
 * Capture tracing data for Hapi.
 * If you also want to capture errors, you need to call `setupHapiErrorHandler(server)` after you set up your server.
 */
const hapiIntegration = defineIntegration(_hapiIntegration);

function isBoomObject(response) {
  return response && (response ).isBoom !== undefined;
}

function isErrorEvent(event) {
  return event && (event ).error !== undefined;
}

function sendErrorToSentry(errorData) {
  captureException(errorData, {
    mechanism: {
      type: 'hapi',
      handled: false,
      data: {
        function: 'hapiErrorPlugin',
      },
    },
  });
}

const hapiErrorPlugin = {
  name: 'SentryHapiErrorPlugin',
  version: SDK_VERSION,
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  register: async function (serverArg) {
    const server = serverArg ;

    server.events.on('request', (request, event) => {
      if (getIsolationScope() !== getDefaultIsolationScope()) {
        const route = request.route;
        if (route && route.path) {
          getIsolationScope().setTransactionName(`${_optionalChain$4([route, 'access', _ => _.method, 'optionalAccess', _2 => _2.toUpperCase, 'call', _3 => _3()]) || 'GET'} ${route.path}`);
        }
      } else {
        DEBUG_BUILD &&
          logger.warn('Isolation scope is still the default isolation scope - skipping setting transactionName');
      }

      const activeSpan = getActiveSpan();
      const rootSpan = activeSpan ? getRootSpan(activeSpan) : undefined;

      if (request.response && isBoomObject(request.response)) {
        sendErrorToSentry(request.response);
      } else if (isErrorEvent(event)) {
        sendErrorToSentry(event.error);
      }

      if (rootSpan) {
        rootSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });
        rootSpan.end();
      }
    });
  },
};

/**
 * Add a Hapi plugin to capture errors to Sentry.
 */
async function setupHapiErrorHandler(server) {
  await server.register(hapiErrorPlugin);

  // eslint-disable-next-line @typescript-eslint/unbound-method
  if (!isWrapped$1(server.register)) {
    consoleSandbox(() => {
      // eslint-disable-next-line no-console
      console.warn(
        '[Sentry] Hapi is not instrumented. This is likely because you required/imported hapi before calling `Sentry.init()`.',
      );
    });
  }
}

const _koaIntegration = (() => {
  return {
    name: 'Koa',
    setupOnce() {
      addOpenTelemetryInstrumentation(
        new KoaInstrumentation({
          requestHook(span, info) {
            if (getIsolationScope() === getDefaultIsolationScope()) {
              DEBUG_BUILD &&
                logger.warn('Isolation scope is default isolation scope - skipping setting transactionName');
              return;
            }
            const attributes = spanToJSON(span).data;
            const route = attributes && attributes[SEMATTRS_HTTP_ROUTE];
            const method = info.context.request.method.toUpperCase() || 'GET';
            if (route) {
              getIsolationScope().setTransactionName(`${method} ${route}`);
            }
          },
        }),
      );
    },
  };
}) ;

const koaIntegration = defineIntegration(_koaIntegration);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
const setupKoaErrorHandler = (app) => {
  app.use(async (ctx, next) => {
    try {
      await next();
    } catch (error) {
      captureException(error);
    }
  });

  if (!isWrapped$1(app.use)) {
    consoleSandbox(() => {
      // eslint-disable-next-line no-console
      console.warn(
        '[Sentry] Koa is not instrumented. This is likely because you required/imported koa before calling `Sentry.init()`.',
      );
    });
  }
};

const _connectIntegration = (() => {
  return {
    name: 'Connect',
    setupOnce() {
      addOpenTelemetryInstrumentation(new ConnectInstrumentation({}));
    },
  };
}) ;

const connectIntegration = defineIntegration(_connectIntegration);

// eslint-disable-next-line @typescript-eslint/no-explicit-any
function connectErrorMiddleware(err, req, res, next) {
  captureException(err);
  next(err);
}

const setupConnectErrorHandler = (app) => {
  app.use(connectErrorMiddleware);

  if (!isWrapped$1(app.use)) {
    consoleSandbox(() => {
      // eslint-disable-next-line no-console
      console.warn(
        '[Sentry] Connect is not instrumented. This is likely because you required/imported connect before calling `Sentry.init()`.',
      );
    });
  }
};

const INTEGRATION_NAME = 'Spotlight';

const _spotlightIntegration = ((options = {}) => {
  const _options = {
    sidecarUrl: options.sidecarUrl || 'http://localhost:8969/stream',
  };

  return {
    name: INTEGRATION_NAME,
    setup(client) {
      if (typeof process === 'object' && process.env && process.env.NODE_ENV !== 'development') {
        logger.warn("[Spotlight] It seems you're not in dev mode. Do you really want to have Spotlight enabled?");
      }
      connectToSpotlight(client, _options);
    },
  };
}) ;

/**
 * Use this integration to send errors and transactions to Spotlight.
 *
 * Learn more about spotlight at https://spotlightjs.com
 *
 * Important: This integration only works with Node 18 or newer.
 */
const spotlightIntegration = defineIntegration(_spotlightIntegration);

function connectToSpotlight(client, options) {
  const spotlightUrl = parseSidecarUrl(options.sidecarUrl);
  if (!spotlightUrl) {
    return;
  }

  let failedRequests = 0;

  client.on('beforeEnvelope', (envelope) => {
    if (failedRequests > 3) {
      logger.warn('[Spotlight] Disabled Sentry -> Spotlight integration due to too many failed requests');
      return;
    }

    const serializedEnvelope = serializeEnvelope(envelope);

    const request = getNativeHttpRequest();
    const req = request(
      {
        method: 'POST',
        path: spotlightUrl.pathname,
        hostname: spotlightUrl.hostname,
        port: spotlightUrl.port,
        headers: {
          'Content-Type': 'application/x-sentry-envelope',
        },
      },
      res => {
        res.on('data', () => {
          // Drain socket
        });

        res.on('end', () => {
          // Drain socket
        });
        res.setEncoding('utf8');
      },
    );

    req.on('error', () => {
      failedRequests++;
      logger.warn('[Spotlight] Failed to send envelope to Spotlight Sidecar');
    });
    req.write(serializedEnvelope);
    req.end();
  });
}

function parseSidecarUrl(url) {
  try {
    return new URL(`${url}`);
  } catch (e) {
    logger.warn(`[Spotlight] Invalid sidecar URL: ${url}`);
    return undefined;
  }
}

/**
 * We want to get an unpatched http request implementation to avoid capturing our own calls.
 */
function getNativeHttpRequest() {
  const { request } = http;
  if (isWrapped(request)) {
    return request.__sentry_original__;
  }

  return request;
}

function isWrapped(impl) {
  return '__sentry_original__' in impl;
}

/**
 * With OTEL, all performance integrations will be added, as OTEL only initializes them when the patched package is actually required.
 */
function getAutoPerformanceIntegrations() {
  return [
    expressIntegration(),
    fastifyIntegration(),
    graphqlIntegration(),
    mongoIntegration(),
    mongooseIntegration(),
    mysqlIntegration(),
    mysql2Integration(),
    redisIntegration(),
    postgresIntegration(),
    // For now, we do not include prisma by default because it has ESM issues
    // See https://github.com/prisma/prisma/issues/23410
    // TODO v8: Figure out a better solution for this, maybe only disable in ESM mode?
    // prismaIntegration(),
    nestIntegration(),
    hapiIntegration(),
    koaIntegration(),
    connectIntegration(),
  ];
}

function _nullishCoalesce$2(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }/**
* This code was originally forked from https://github.com/TooTallNate/proxy-agents/tree/b133295fd16f6475578b6b15bd9b4e33ecb0d0b7
* With the following licence:
*
* (The MIT License)
*
* Copyright (c) 2013 Nathan Rajlich <nathan@tootallnate.net>*
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* 'Software'), to deal in the Software without restriction, including
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:*
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.*
*
* THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
* IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
* CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
* TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
* SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

const INTERNAL = Symbol('AgentBaseInternalState');

class Agent extends http.Agent {

  // Set by `http.Agent` - missing from `@types/node`

  constructor(opts) {
    super(opts);
    this[INTERNAL] = {};
  }

  /**
   * Determine whether this is an `http` or `https` request.
   */
  isSecureEndpoint(options) {
    if (options) {
      // First check the `secureEndpoint` property explicitly, since this
      // means that a parent `Agent` is "passing through" to this instance.
      // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access
      if (typeof (options ).secureEndpoint === 'boolean') {
        return options.secureEndpoint;
      }

      // If no explicit `secure` endpoint, check if `protocol` property is
      // set. This will usually be the case since using a full string URL
      // or `URL` instance should be the most common usage.
      if (typeof options.protocol === 'string') {
        return options.protocol === 'https:';
      }
    }

    // Finally, if no `protocol` property was set, then fall back to
    // checking the stack trace of the current call stack, and try to
    // detect the "https" module.
    const { stack } = new Error();
    if (typeof stack !== 'string') return false;
    return stack.split('\n').some(l => l.indexOf('(https.js:') !== -1 || l.indexOf('node:https:') !== -1);
  }

  createSocket(req, options, cb) {
    const connectOpts = {
      ...options,
      secureEndpoint: this.isSecureEndpoint(options),
    };
    Promise.resolve()
      .then(() => this.connect(req, connectOpts))
      .then(socket => {
        if (socket instanceof http.Agent) {
          // @ts-expect-error `addRequest()` isn't defined in `@types/node`
          return socket.addRequest(req, connectOpts);
        }
        this[INTERNAL].currentSocket = socket;
        // @ts-expect-error `createSocket()` isn't defined in `@types/node`
        super.createSocket(req, options, cb);
      }, cb);
  }

  createConnection() {
    const socket = this[INTERNAL].currentSocket;
    this[INTERNAL].currentSocket = undefined;
    if (!socket) {
      throw new Error('No socket was returned in the `connect()` function');
    }
    return socket;
  }

  get defaultPort() {
    return _nullishCoalesce$2(this[INTERNAL].defaultPort, () => ( (this.protocol === 'https:' ? 443 : 80)));
  }

  set defaultPort(v) {
    if (this[INTERNAL]) {
      this[INTERNAL].defaultPort = v;
    }
  }

  get protocol() {
    return _nullishCoalesce$2(this[INTERNAL].protocol, () => ( (this.isSecureEndpoint() ? 'https:' : 'http:')));
  }

  set protocol(v) {
    if (this[INTERNAL]) {
      this[INTERNAL].protocol = v;
    }
  }
}

function debug$1(...args) {
  logger.log('[https-proxy-agent:parse-proxy-response]', ...args);
}

function parseProxyResponse(socket) {
  return new Promise((resolve, reject) => {
    // we need to buffer any HTTP traffic that happens with the proxy before we get
    // the CONNECT response, so that if the response is anything other than an "200"
    // response code, then we can re-play the "data" events on the socket once the
    // HTTP parser is hooked up...
    let buffersLength = 0;
    const buffers = [];

    function read() {
      const b = socket.read();
      if (b) ondata(b);
      else socket.once('readable', read);
    }

    function cleanup() {
      socket.removeListener('end', onend);
      socket.removeListener('error', onerror);
      socket.removeListener('readable', read);
    }

    function onend() {
      cleanup();
      debug$1('onend');
      reject(new Error('Proxy connection ended before receiving CONNECT response'));
    }

    function onerror(err) {
      cleanup();
      debug$1('onerror %o', err);
      reject(err);
    }

    function ondata(b) {
      buffers.push(b);
      buffersLength += b.length;

      const buffered = Buffer.concat(buffers, buffersLength);
      const endOfHeaders = buffered.indexOf('\r\n\r\n');

      if (endOfHeaders === -1) {
        // keep buffering
        debug$1('have not received end of HTTP headers yet...');
        read();
        return;
      }

      const headerParts = buffered.slice(0, endOfHeaders).toString('ascii').split('\r\n');
      const firstLine = headerParts.shift();
      if (!firstLine) {
        socket.destroy();
        return reject(new Error('No header received from proxy CONNECT response'));
      }
      const firstLineParts = firstLine.split(' ');
      const statusCode = +firstLineParts[1];
      const statusText = firstLineParts.slice(2).join(' ');
      const headers = {};
      for (const header of headerParts) {
        if (!header) continue;
        const firstColon = header.indexOf(':');
        if (firstColon === -1) {
          socket.destroy();
          return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
        }
        const key = header.slice(0, firstColon).toLowerCase();
        const value = header.slice(firstColon + 1).trimStart();
        const current = headers[key];
        if (typeof current === 'string') {
          headers[key] = [current, value];
        } else if (Array.isArray(current)) {
          current.push(value);
        } else {
          headers[key] = value;
        }
      }
      debug$1('got proxy server response: %o %o', firstLine, headers);
      cleanup();
      resolve({
        connect: {
          statusCode,
          statusText,
          headers,
        },
        buffered,
      });
    }

    socket.on('error', onerror);
    socket.on('end', onend);

    read();
  });
}

function _nullishCoalesce$1(lhs, rhsFn) { if (lhs != null) { return lhs; } else { return rhsFn(); } }function _optionalChain$3(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }

function debug(...args) {
  logger.log('[https-proxy-agent]', ...args);
}

/**
 * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to
 * the specified "HTTP(s) proxy server" in order to proxy HTTPS requests.
 *
 * Outgoing HTTP requests are first tunneled through the proxy server using the
 * `CONNECT` HTTP request method to establish a connection to the proxy server,
 * and then the proxy server connects to the destination target and issues the
 * HTTP request from the proxy server.
 *
 * `https:` requests have their socket connection upgraded to TLS once
 * the connection to the proxy server has been established.
 */
class HttpsProxyAgent extends Agent {
  static __initStatic() {this.protocols = ['http', 'https']; }

  constructor(proxy, opts) {
    super(opts);
    this.options = {};
    this.proxy = typeof proxy === 'string' ? new URL(proxy) : proxy;
    this.proxyHeaders = _nullishCoalesce$1(_optionalChain$3([opts, 'optionalAccess', _2 => _2.headers]), () => ( {}));
    debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);

    // Trim off the brackets from IPv6 addresses
    const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, '');
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === 'https:' ? 443 : 80;
    this.connectOpts = {
      // Attempt to negotiate http/1.1 for proxy servers that support http/2
      ALPNProtocols: ['http/1.1'],
      ...(opts ? omit(opts, 'headers') : null),
      host,
      port,
    };
  }

  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   */
  async connect(req, opts) {
    const { proxy } = this;

    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }

    // Create a socket connection to the proxy server.
    let socket;
    if (proxy.protocol === 'https:') {
      debug('Creating `tls.Socket`: %o', this.connectOpts);
      const servername = this.connectOpts.servername || this.connectOpts.host;
      socket = tls.connect({
        ...this.connectOpts,
        servername: servername && net.isIP(servername) ? undefined : servername,
      });
    } else {
      debug('Creating `net.Socket`: %o', this.connectOpts);
      socket = net.connect(this.connectOpts);
    }

    const headers =
      typeof this.proxyHeaders === 'function' ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;

    // Inject the `Proxy-Authorization` header if necessary.
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;
    }

    headers.Host = `${host}:${opts.port}`;

    if (!headers['Proxy-Connection']) {
      headers['Proxy-Connection'] = this.keepAlive ? 'Keep-Alive' : 'close';
    }
    for (const name of Object.keys(headers)) {
      payload += `${name}: ${headers[name]}\r\n`;
    }

    const proxyResponsePromise = parseProxyResponse(socket);

    socket.write(`${payload}\r\n`);

    const { connect, buffered } = await proxyResponsePromise;
    req.emit('proxyConnect', connect);
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore Not EventEmitter in Node types
    this.emit('proxyConnect', connect, req);

    if (connect.statusCode === 200) {
      req.once('socket', resume);

      if (opts.secureEndpoint) {
        // The proxy is connecting to a TLS server, so upgrade
        // this socket connection to a TLS connection.
        debug('Upgrading socket connection to TLS');
        const servername = opts.servername || opts.host;
        return tls.connect({
          ...omit(opts, 'host', 'path', 'port'),
          socket,
          servername: net.isIP(servername) ? undefined : servername,
        });
      }

      return socket;
    }

    // Some other status code that's not 200... need to re-play the HTTP
    // header "data" events onto the socket once the HTTP machinery is
    // attached so that the node core `http` can parse and handle the
    // error status code.

    // Close the original socket, and a new "fake" socket is returned
    // instead, so that the proxy doesn't get the HTTP request
    // written to it (which may contain `Authorization` headers or other
    // sensitive data).
    //
    // See: https://hackerone.com/reports/541502
    socket.destroy();

    const fakeSocket = new net.Socket({ writable: false });
    fakeSocket.readable = true;

    // Need to wait for the "socket" event to re-play the "data" events.
    req.once('socket', (s) => {
      debug('Replaying proxy buffer for failed request');
      // Replay the "buffered" Buffer onto the fake `socket`, since at
      // this point the HTTP module machinery has been hooked up for
      // the user.
      s.push(buffered);
      s.push(null);
    });

    return fakeSocket;
  }
}HttpsProxyAgent.__initStatic();

function resume(socket) {
  socket.resume();
}

function omit(
  obj,
  ...keys
)

 {
  const ret = {}

;
  let key;
  for (key in obj) {
    if (!keys.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}

// Estimated maximum size for reasonable standalone event
const GZIP_THRESHOLD = 1024 * 32;

/**
 * Gets a stream from a Uint8Array or string
 * Readable.from is ideal but was added in node.js v12.3.0 and v10.17.0
 */
function streamFromBody(body) {
  return new Readable({
    read() {
      this.push(body);
      this.push(null);
    },
  });
}

/**
 * Creates a Transport that uses native the native 'http' and 'https' modules to send events to Sentry.
 */
function makeNodeTransport(options) {
  let urlSegments;

  try {
    urlSegments = new URL(options.url);
  } catch (e) {
    consoleSandbox(() => {
      // eslint-disable-next-line no-console
      console.warn(
        '[@sentry/node]: Invalid dsn or tunnel option, will not send any events. The tunnel option must be a full URL when used.',
      );
    });
    return createTransport(options, () => Promise.resolve({}));
  }

  const isHttps = urlSegments.protocol === 'https:';

  // Proxy prioritization: http => `options.proxy` | `process.env.http_proxy`
  // Proxy prioritization: https => `options.proxy` | `process.env.https_proxy` | `process.env.http_proxy`
  const proxy = applyNoProxyOption(
    urlSegments,
    options.proxy || (isHttps ? process.env.https_proxy : undefined) || process.env.http_proxy,
  );

  const nativeHttpModule = isHttps ? https : http$1;
  const keepAlive = options.keepAlive === undefined ? false : options.keepAlive;

  // TODO(v7): Evaluate if we can set keepAlive to true. This would involve testing for memory leaks in older node
  // versions(>= 8) as they had memory leaks when using it: #2555
  const agent = proxy
    ? (new HttpsProxyAgent(proxy) )
    : new nativeHttpModule.Agent({ keepAlive, maxSockets: 30, timeout: 2000 });

  // This ensures we do not generate any spans in OpenTelemetry for the transport
  return suppressTracing(() => {
    const requestExecutor = createRequestExecutor(options, _nullishCoalesce(options.httpModule, () => ( nativeHttpModule)), agent);
    return createTransport(options, requestExecutor);
  });
}

/**
 * Honors the `no_proxy` env variable with the highest priority to allow for hosts exclusion.
 *
 * @param transportUrl The URL the transport intends to send events to.
 * @param proxy The client configured proxy.
 * @returns A proxy the transport should use.
 */
function applyNoProxyOption(transportUrlSegments, proxy) {
  const { no_proxy } = process.env;

  const urlIsExemptFromProxy =
    no_proxy &&
    no_proxy
      .split(',')
      .some(
        exemption => transportUrlSegments.host.endsWith(exemption) || transportUrlSegments.hostname.endsWith(exemption),
      );

  if (urlIsExemptFromProxy) {
    return undefined;
  } else {
    return proxy;
  }
}

/**
 * Creates a RequestExecutor to be used with `createTransport`.
 */
function createRequestExecutor(
  options,
  httpModule,
  agent,
) {
  const { hostname, pathname, port, protocol, search } = new URL(options.url);
  return function makeRequest(request) {
    return new Promise((resolve, reject) => {
      let body = streamFromBody(request.body);

      const headers = { ...options.headers };

      if (request.body.length > GZIP_THRESHOLD) {
        headers['content-encoding'] = 'gzip';
        body = body.pipe(createGzip());
      }

      const req = httpModule.request(
        {
          method: 'POST',
          agent,
          headers,
          hostname,
          path: `${pathname}${search}`,
          port,
          protocol,
          ca: options.caCerts,
        },
        res => {
          res.on('data', () => {
            // Drain socket
          });

          res.on('end', () => {
            // Drain socket
          });

          res.setEncoding('utf8');

          // "Key-value pairs of header names and values. Header names are lower-cased."
          // https://nodejs.org/api/http.html#http_message_headers
          const retryAfterHeader = _nullishCoalesce(res.headers['retry-after'], () => ( null));
          const rateLimitsHeader = _nullishCoalesce(res.headers['x-sentry-rate-limits'], () => ( null));

          resolve({
            statusCode: res.statusCode,
            headers: {
              'retry-after': retryAfterHeader,
              'x-sentry-rate-limits': Array.isArray(rateLimitsHeader) ? rateLimitsHeader[0] : rateLimitsHeader,
            },
          });
        },
      );

      req.on('error', reject);
      body.pipe(req);
    });
  };
}

/** normalizes Windows paths */
function normalizeWindowsPath(path) {
  return path
    .replace(/^[A-Z]:/, '') // remove Windows-style prefix
    .replace(/\\/g, '/'); // replace all `\` instances with `/`
}

/** Creates a function that gets the module name from a filename */
function createGetModuleFromFilename(
  basePath = process.argv[1] ? dirname$1(process.argv[1]) : process.cwd(),
  isWindows = sep === '\\',
) {
  const normalizedBase = isWindows ? normalizeWindowsPath(basePath) : basePath;

  return (filename) => {
    if (!filename) {
      return;
    }

    const normalizedFilename = isWindows ? normalizeWindowsPath(filename) : filename;

    // eslint-disable-next-line prefer-const
    let { dir, base: file, ext } = posix.parse(normalizedFilename);

    if (ext === '.js' || ext === '.mjs' || ext === '.cjs') {
      file = file.slice(0, ext.length * -1);
    }

    if (!dir) {
      // No dirname whatsoever
      dir = '.';
    }

    const n = dir.lastIndexOf('/node_modules');
    if (n > -1) {
      return `${dir.slice(n + 14).replace(/\//g, '.')}:${file}`;
    }

    // Let's see if it's a part of the main module
    // To be a part of main module, it has to share the same base
    if (dir.startsWith(normalizedBase)) {
      let moduleName = dir.slice(normalizedBase.length + 1).replace(/\//g, '.');

      if (moduleName) {
        moduleName += ':';
      }
      moduleName += file;

      return moduleName;
    }

    return file;
  };
}

/**
 * Returns a release dynamically from environment variables.
 */
function getSentryRelease(fallback) {
  // Always read first as Sentry takes this as precedence
  if (process.env.SENTRY_RELEASE) {
    return process.env.SENTRY_RELEASE;
  }

  // This supports the variable that sentry-webpack-plugin injects
  if (GLOBAL_OBJ.SENTRY_RELEASE && GLOBAL_OBJ.SENTRY_RELEASE.id) {
    return GLOBAL_OBJ.SENTRY_RELEASE.id;
  }

  return (
    // GitHub Actions - https://help.github.com/en/actions/configuring-and-managing-workflows/using-environment-variables#default-environment-variables
    process.env.GITHUB_SHA ||
    // Netlify - https://docs.netlify.com/configure-builds/environment-variables/#build-metadata
    process.env.COMMIT_REF ||
    // Vercel - https://vercel.com/docs/v2/build-step#system-environment-variables
    process.env.VERCEL_GIT_COMMIT_SHA ||
    process.env.VERCEL_GITHUB_COMMIT_SHA ||
    process.env.VERCEL_GITLAB_COMMIT_SHA ||
    process.env.VERCEL_BITBUCKET_COMMIT_SHA ||
    // Zeit (now known as Vercel)
    process.env.ZEIT_GITHUB_COMMIT_SHA ||
    process.env.ZEIT_GITLAB_COMMIT_SHA ||
    process.env.ZEIT_BITBUCKET_COMMIT_SHA ||
    // Cloudflare Pages - https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables
    process.env.CF_PAGES_COMMIT_SHA ||
    fallback
  );
}

/** Node.js stack parser */
const defaultStackParser = createStackParser(nodeStackLineParser(createGetModuleFromFilename()));

function _optionalChain$2(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
/** A client for using Sentry with Node & OpenTelemetry. */
class NodeClient extends ServerRuntimeClient {

   constructor(options) {
    const clientOptions = {
      ...options,
      platform: 'node',
      runtime: { name: 'node', version: global.process.version },
      serverName: options.serverName || global.process.env.SENTRY_NAME || os.hostname(),
    };

    applySdkMetadata(clientOptions, 'node');

    logger.log(
      `Initializing Sentry: process: ${process.pid}, thread: ${isMainThread ? 'main' : `worker-${threadId}`}.`,
    );

    super(clientOptions);
  }

  /** Get the OTEL tracer. */
   get tracer() {
    if (this._tracer) {
      return this._tracer;
    }

    const name = '@sentry/node';
    const version = SDK_VERSION;
    const tracer = trace.getTracer(name, version);
    this._tracer = tracer;

    return tracer;
  }

  /**
   * @inheritDoc
   */
   async flush(timeout) {
    const provider = this.traceProvider;
    const spanProcessor = _optionalChain$2([provider, 'optionalAccess', _ => _.activeSpanProcessor]);

    if (spanProcessor) {
      await spanProcessor.forceFlush();
    }

    return super.flush(timeout);
  }
}

/**
 * This is a custom ContextManager for OpenTelemetry, which extends the default AsyncLocalStorageContextManager.
 * It ensures that we create a new hub per context, so that the OTEL Context & the Sentry Hub are always in sync.
 *
 * Note that we currently only support AsyncHooks with this,
 * but since this should work for Node 14+ anyhow that should be good enough.
 */
const SentryContextManager = wrapContextManagerClass(AsyncLocalStorageContextManager);

/**
 * Initialize OpenTelemetry for Node.
 */
function initOpenTelemetry(client) {
  if (client.getOptions().debug) {
    const otelLogger = new Proxy(logger , {
      get(target, prop, receiver) {
        const actualProp = prop === 'verbose' ? 'debug' : prop;
        return Reflect.get(target, actualProp, receiver);
      },
    });

    diag.setLogger(otelLogger, DiagLogLevel.DEBUG);
  }

  setupEventContextTrace(client);

  const provider = setupOtel(client);
  client.traceProvider = provider;
}

/** Just exported for tests. */
function setupOtel(client) {
  // Create and configure NodeTracerProvider
  const provider = new BasicTracerProvider({
    sampler: new SentrySampler(client),
    resource: new Resource({
      [SEMRESATTRS_SERVICE_NAME]: 'node',
      [SEMRESATTRS_SERVICE_NAMESPACE]: 'sentry',
      [SEMRESATTRS_SERVICE_VERSION]: SDK_VERSION,
    }),
    forceFlushTimeoutMillis: 500,
  });
  provider.addSpanProcessor(new SentrySpanProcessor());

  // Initialize the provider
  provider.register({
    propagator: new SentryPropagator(),
    contextManager: new SentryContextManager(),
  });

  return provider;
}

function isCjs() {
  return typeof require !== 'undefined';
}

function getCjsOnlyIntegrations() {
  return isCjs() ? [modulesIntegration()] : [];
}

/**
 * Get default integrations, excluding performance.
 */
function getDefaultIntegrationsWithoutPerformance() {
  return [
    // Common
    inboundFiltersIntegration(),
    functionToStringIntegration(),
    linkedErrorsIntegration(),
    requestDataIntegration(),
    // Native Wrappers
    consoleIntegration(),
    httpIntegration(),
    nativeNodeFetchIntegration(),
    // Global Handlers
    onUncaughtExceptionIntegration(),
    onUnhandledRejectionIntegration(),
    // Event Info
    contextLinesIntegration(),
    localVariablesIntegration(),
    nodeContextIntegration(),
    ...getCjsOnlyIntegrations(),
  ];
}

/** Get the default integrations for the Node SDK. */
function getDefaultIntegrations(options) {
  return [
    ...getDefaultIntegrationsWithoutPerformance(),
    ...(hasTracingEnabled(options) ? getAutoPerformanceIntegrations() : []),
  ];
}

/**
 * Initialize Sentry for Node.
 */
function init(options = {}) {
  const clientOptions = getClientOptions(options);

  if (clientOptions.debug === true) {
    if (DEBUG_BUILD) {
      logger.enable();
    } else {
      // use `console.warn` rather than `logger.warn` since by non-debug bundles have all `logger.x` statements stripped
      consoleSandbox(() => {
        // eslint-disable-next-line no-console
        console.warn('[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.');
      });
    }
  }

  if (!isCjs()) {
    const [nodeMajor, nodeMinor] = process.versions.node.split('.').map(Number);

    // Register hook was added in v20.6.0 and v18.19.0
    if (nodeMajor >= 22 || (nodeMajor === 20 && nodeMinor >= 6) || (nodeMajor === 18 && nodeMinor >= 19)) {
      // We need to work around using import.meta.url directly because jest complains about it.
      const importMetaUrl =
        typeof import.meta.url !== 'undefined' ? import.meta.url : undefined;

      if (!GLOBAL_OBJ._sentryEsmLoaderHookRegistered && importMetaUrl) {
        // @ts-expect-error register is available in these versions
        moduleModule.register('@opentelemetry/instrumentation/hook.mjs', importMetaUrl);
        GLOBAL_OBJ._sentryEsmLoaderHookRegistered = true;
      }
    } else {
      consoleSandbox(() => {
        // eslint-disable-next-line no-console
        console.warn(
          '[Sentry] You are using Node.js in ESM mode ("import syntax"). The Sentry Node.js SDK is not compatible with ESM in Node.js versions before 18.19.0 or before 20.6.0. Please either build your application with CommonJS ("require() syntax"), or use version 7.x of the Sentry Node.js SDK.',
        );
      });
    }
  }

  setOpenTelemetryContextAsyncContextStrategy();

  const scope = getCurrentScope();
  scope.update(options.initialScope);

  const client = new NodeClient(clientOptions);
  // The client is on the current scope, from where it generally is inherited
  getCurrentScope().setClient(client);

  if (isEnabled(client)) {
    client.init();
  }

  if (options.autoSessionTracking) {
    startSessionTracking();
  }

  updateScopeFromEnvVariables();

  if (options.spotlight) {
    // force integrations to be setup even if no DSN was set
    // If they have already been added before, they will be ignored anyhow
    const integrations = client.getOptions().integrations;
    for (const integration of integrations) {
      client.addIntegration(integration);
    }
    client.addIntegration(
      spotlightIntegration({
        sidecarUrl: typeof options.spotlight === 'string' ? options.spotlight : undefined,
      }),
    );
  }

  // If users opt-out of this, they _have_ to set up OpenTelemetry themselves
  // There is no way to use this SDK without OpenTelemetry!
  if (!options.skipOpenTelemetrySetup) {
    initOpenTelemetry(client);
  }

  validateOpenTelemetrySetup();
}

function validateOpenTelemetrySetup() {
  if (!DEBUG_BUILD) {
    return;
  }

  const setup = openTelemetrySetupCheck();

  const required = ['SentrySpanProcessor', 'SentryContextManager', 'SentryPropagator'] ;
  for (const k of required) {
    if (!setup.includes(k)) {
      logger.error(
        `You have to set up the ${k}. Without this, the OpenTelemetry & Sentry integration will not work properly.`,
      );
    }
  }

  if (!setup.includes('SentrySampler')) {
    logger.warn(
      'You have to set up the SentrySampler. Without this, the OpenTelemetry & Sentry integration may still work, but sample rates set for the Sentry SDK will not be respected.',
    );
  }
}

function getClientOptions(options) {
  const release = getRelease(options.release);

  const autoSessionTracking =
    typeof release !== 'string'
      ? false
      : options.autoSessionTracking === undefined
        ? true
        : options.autoSessionTracking;

  const tracesSampleRate = getTracesSampleRate(options.tracesSampleRate);

  const baseOptions = dropUndefinedKeys({
    transport: makeNodeTransport,
    dsn: process.env.SENTRY_DSN,
    environment: process.env.SENTRY_ENVIRONMENT,
  });

  const overwriteOptions = dropUndefinedKeys({
    release,
    autoSessionTracking,
    tracesSampleRate,
  });

  if (options.defaultIntegrations === undefined) {
    options.defaultIntegrations = getDefaultIntegrations({
      ...options,
      ...overwriteOptions,
    });
  }

  const clientOptions = {
    ...baseOptions,
    ...options,
    ...overwriteOptions,
    stackParser: stackParserFromStackParserOptions(options.stackParser || defaultStackParser),
    integrations: getIntegrationsToSetup({
      defaultIntegrations: options.defaultIntegrations,
      integrations: options.integrations,
    }),
  };

  return clientOptions;
}

function getRelease(release) {
  if (release !== undefined) {
    return release;
  }

  const detectedRelease = getSentryRelease();
  if (detectedRelease !== undefined) {
    return detectedRelease;
  }

  return undefined;
}

function getTracesSampleRate(tracesSampleRate) {
  if (tracesSampleRate !== undefined) {
    return tracesSampleRate;
  }

  const sampleRateFromEnv = process.env.SENTRY_TRACES_SAMPLE_RATE;
  if (!sampleRateFromEnv) {
    return undefined;
  }

  const parsed = parseFloat(sampleRateFromEnv);
  return isFinite(parsed) ? parsed : undefined;
}

/**
 * Update scope and propagation context based on environmental variables.
 *
 * See https://github.com/getsentry/rfcs/blob/main/text/0071-continue-trace-over-process-boundaries.md
 * for more details.
 */
function updateScopeFromEnvVariables() {
  const sentryUseEnvironment = (process.env.SENTRY_USE_ENVIRONMENT || '').toLowerCase();
  if (!['false', 'n', 'no', 'off', '0'].includes(sentryUseEnvironment)) {
    const sentryTraceEnv = process.env.SENTRY_TRACE;
    const baggageEnv = process.env.SENTRY_BAGGAGE;
    const propagationContext = propagationContextFromHeaders(sentryTraceEnv, baggageEnv);
    getCurrentScope().setPropagationContext(propagationContext);
  }
}

/**
 * Enable automatic Session Tracking for the node process.
 */
function startSessionTracking() {
  const client = getClient$1();
  if (client && client.getOptions().autoSessionTracking) {
    client.initSessionFlusher();
  }

  startSession();

  // Emitted in the case of healthy sessions, error of `mechanism.handled: true` and unhandledrejections because
  // The 'beforeExit' event is not emitted for conditions causing explicit termination,
  // such as calling process.exit() or uncaught exceptions.
  // Ref: https://nodejs.org/api/process.html#process_event_beforeexit
  process.on('beforeExit', () => {
    const session = getIsolationScope().getSession();

    // Only call endSession, if the Session exists on Scope and SessionStatus is not a
    // Terminal Status i.e. Exited or Crashed because
    // "When a session is moved away from ok it must not be updated anymore."
    // Ref: https://develop.sentry.dev/sdk/sessions/
    if (session && session.status !== 'ok') {
      endSession();
    }
  });
}

function isEnabled(client) {
  return client.getOptions().enabled !== false && client.getTransport() !== undefined;
}

const replacements = [
  ['january', '1'],
  ['february', '2'],
  ['march', '3'],
  ['april', '4'],
  ['may', '5'],
  ['june', '6'],
  ['july', '7'],
  ['august', '8'],
  ['september', '9'],
  ['october', '10'],
  ['november', '11'],
  ['december', '12'],
  ['jan', '1'],
  ['feb', '2'],
  ['mar', '3'],
  ['apr', '4'],
  ['may', '5'],
  ['jun', '6'],
  ['jul', '7'],
  ['aug', '8'],
  ['sep', '9'],
  ['oct', '10'],
  ['nov', '11'],
  ['dec', '12'],
  ['sunday', '0'],
  ['monday', '1'],
  ['tuesday', '2'],
  ['wednesday', '3'],
  ['thursday', '4'],
  ['friday', '5'],
  ['saturday', '6'],
  ['sun', '0'],
  ['mon', '1'],
  ['tue', '2'],
  ['wed', '3'],
  ['thu', '4'],
  ['fri', '5'],
  ['sat', '6'],
];

/**
 * Replaces names in cron expressions
 */
function replaceCronNames(cronExpression) {
  return replacements.reduce(
    // eslint-disable-next-line @sentry-internal/sdk/no-regexp-constructor
    (acc, [name, replacement]) => acc.replace(new RegExp(name, 'gi'), replacement),
    cronExpression,
  );
}

const ERROR_TEXT = 'Automatic instrumentation of CronJob only supports crontab string';

/**
 * Instruments the `cron` library to send a check-in event to Sentry for each job execution.
 *
 * ```ts
 * import * as Sentry from '@sentry/node';
 * import { CronJob } from 'cron';
 *
 * const CronJobWithCheckIn = Sentry.cron.instrumentCron(CronJob, 'my-cron-job');
 *
 * // use the constructor
 * const job = new CronJobWithCheckIn('* * * * *', () => {
 *  console.log('You will see this message every minute');
 * });
 *
 * // or from
 * const job = CronJobWithCheckIn.from({ cronTime: '* * * * *', onTick: () => {
 *   console.log('You will see this message every minute');
 * });
 * ```
 */
function instrumentCron(lib, monitorSlug) {
  let jobScheduled = false;

  return new Proxy(lib, {
    construct(target, args) {
      const [cronTime, onTick, onComplete, start, timeZone, ...rest] = args;

      if (typeof cronTime !== 'string') {
        throw new Error(ERROR_TEXT);
      }

      if (jobScheduled) {
        throw new Error(`A job named '${monitorSlug}' has already been scheduled`);
      }

      jobScheduled = true;

      const cronString = replaceCronNames(cronTime);

      async function monitoredTick(context, onComplete) {
        return withMonitor(
          monitorSlug,
          async () => {
            try {
              await onTick(context, onComplete);
            } catch (e) {
              captureException(e);
              throw e;
            }
          },
          {
            schedule: { type: 'crontab', value: cronString },
            timezone: timeZone || undefined,
          },
        );
      }

      return new target(cronTime, monitoredTick, onComplete, start, timeZone, ...rest);
    },
    get(target, prop) {
      if (prop === 'from') {
        return (param) => {
          const { cronTime, onTick, timeZone } = param;

          if (typeof cronTime !== 'string') {
            throw new Error(ERROR_TEXT);
          }

          if (jobScheduled) {
            throw new Error(`A job named '${monitorSlug}' has already been scheduled`);
          }

          jobScheduled = true;

          const cronString = replaceCronNames(cronTime);

          param.onTick = async (context, onComplete) => {
            return withMonitor(
              monitorSlug,
              async () => {
                try {
                  await onTick(context, onComplete);
                } catch (e) {
                  captureException(e);
                  throw e;
                }
              },
              {
                schedule: { type: 'crontab', value: cronString },
                timezone: timeZone || undefined,
              },
            );
          };

          return target.from(param);
        };
      } else {
        return target[prop];
      }
    },
  });
}

function _optionalChain$1(ops) { let lastAccessLHS = undefined; let value = ops[0]; let i = 1; while (i < ops.length) { const op = ops[i]; const fn = ops[i + 1]; i += 2; if ((op === 'optionalAccess' || op === 'optionalCall') && value == null) { return undefined; } if (op === 'access' || op === 'optionalAccess') { lastAccessLHS = value; value = fn(value); } else if (op === 'call' || op === 'optionalCall') { value = fn((...args) => value.call(lastAccessLHS, ...args)); lastAccessLHS = undefined; } } return value; }
/**
 * Wraps the `node-cron` library with check-in monitoring.
 *
 * ```ts
 * import * as Sentry from "@sentry/node";
 * import * as cron from "node-cron";
 *
 * const cronWithCheckIn = Sentry.cron.instrumentNodeCron(cron);
 *
 * cronWithCheckIn.schedule(
 *   "* * * * *",
 *   () => {
 *     console.log("running a task every minute");
 *   },
 *   { name: "my-cron-job" },
 * );
 * ```
 */
function instrumentNodeCron(lib) {
  return new Proxy(lib, {
    get(target, prop) {
      if (prop === 'schedule' && target.schedule) {
        // When 'get' is called for schedule, return a proxied version of the schedule function
        return new Proxy(target.schedule, {
          apply(target, thisArg, argArray) {
            const [expression, callback, options] = argArray;

            if (!_optionalChain$1([options, 'optionalAccess', _ => _.name])) {
              throw new Error('Missing "name" for scheduled job. A name is required for Sentry check-in monitoring.');
            }

            async function monitoredCallback() {
              return withMonitor(
                options.name,
                async () => {
                  // We have to manually catch here and capture the exception because node-cron swallows errors
                  // https://github.com/node-cron/node-cron/issues/399
                  try {
                    return await callback();
                  } catch (e) {
                    captureException(e);
                    throw e;
                  }
                },
                {
                  schedule: { type: 'crontab', value: replaceCronNames(expression) },
                  timezone: _optionalChain$1([options, 'optionalAccess', _2 => _2.timezone]),
                },
              );
            }

            return target.apply(thisArg, [expression, monitoredCallback, options]);
          },
        });
      } else {
        return target[prop];
      }
    },
  });
}

/**
 * Instruments the `node-schedule` library to send a check-in event to Sentry for each job execution.
 *
 * ```ts
 * import * as Sentry from '@sentry/node';
 * import * as schedule from 'node-schedule';
 *
 * const scheduleWithCheckIn = Sentry.cron.instrumentNodeSchedule(schedule);
 *
 * const job = scheduleWithCheckIn.scheduleJob('my-cron-job', '* * * * *', () => {
 *  console.log('You will see this message every minute');
 * });
 * ```
 */
function instrumentNodeSchedule(lib) {
  return new Proxy(lib, {
    get(target, prop) {
      if (prop === 'scheduleJob') {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        return new Proxy(target.scheduleJob, {
          apply(target, thisArg, argArray) {
            const [nameOrExpression, expressionOrCallback, callback] = argArray;

            if (
              typeof nameOrExpression !== 'string' ||
              typeof expressionOrCallback !== 'string' ||
              typeof callback !== 'function'
            ) {
              throw new Error(
                "Automatic instrumentation of 'node-schedule' requires the first parameter of 'scheduleJob' to be a job name string and the second parameter to be a crontab string",
              );
            }

            const monitorSlug = nameOrExpression;
            const expression = expressionOrCallback;

            async function monitoredCallback() {
              return withMonitor(
                monitorSlug,
                async () => {
                  await _optionalChain([callback, 'optionalCall', _ => _()]);
                },
                {
                  schedule: { type: 'crontab', value: replaceCronNames(expression) },
                },
              );
            }

            return target.apply(thisArg, [monitorSlug, expression, monitoredCallback]);
          },
        });
      }

      return target[prop];
    },
  });
}

/** Methods to instrument cron libraries for Sentry check-ins */
const cron = {
  instrumentCron,
  instrumentNodeCron,
  instrumentNodeSchedule,
};

export { NodeClient, anrIntegration, connectIntegration, consoleIntegration, contextLinesIntegration, createGetModuleFromFilename, cron, defaultStackParser, expressErrorHandler, expressIntegration, fastifyIntegration, getAutoPerformanceIntegrations, getDefaultIntegrations, getDefaultIntegrationsWithoutPerformance, getSentryRelease, graphqlIntegration, hapiIntegration, httpIntegration, init, initOpenTelemetry, koaIntegration, localVariablesIntegration, makeNodeTransport, modulesIntegration, mongoIntegration, mongooseIntegration, mysql2Integration, mysqlIntegration, nativeNodeFetchIntegration, nestIntegration, nodeContextIntegration, onUncaughtExceptionIntegration, onUnhandledRejectionIntegration, postgresIntegration, prismaIntegration, redisIntegration, setupConnectErrorHandler, setupExpressErrorHandler, setupFastifyErrorHandler, setupHapiErrorHandler, setupKoaErrorHandler, setupNestErrorHandler, spotlightIntegration };
//# sourceMappingURL=index.js.map
