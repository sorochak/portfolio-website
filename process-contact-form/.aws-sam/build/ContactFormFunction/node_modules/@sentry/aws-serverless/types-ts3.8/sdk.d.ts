import { NodeOptions } from '@sentry/node';
import { Integration, Options } from '@sentry/types';
import { Handler } from 'aws-lambda';
export type AsyncHandler<T extends Handler> = (event: Parameters<T>[0], context: Parameters<T>[1]) => Promise<NonNullable<Parameters<Parameters<T>[2]>[1]>>;
export interface WrapperOptions {
    flushTimeout: number;
    callbackWaitsForEmptyEventLoop: boolean;
    captureTimeoutWarning: boolean;
    timeoutWarningLimit: number;
    /**
     * Capture all errors when `Promise.allSettled` is returned by the handler
     * The {@link wrapHandler} will not fail the lambda even if there are errors
     * @default false
     */
    captureAllSettledReasons: boolean;
    /**
     * Automatically trace all handler invocations.
     * You may want to disable this if you use express within Lambda (use tracingHandler instead).
     * @default true
     */
    startTrace: boolean;
}
/**
 * Get the default integrations for the AWSLambda SDK.
 */
export declare function getDefaultIntegrations(_options: Options): Integration[];
/**
 * Initializes the Sentry AWS Lambda SDK.
 *
 * @param options Configuration options for the SDK, @see {@link AWSLambdaOptions}.
 */
export declare function init(options?: NodeOptions): void;
/** */
export declare function tryPatchHandler(taskRoot: string, handlerPath: string): void;
/**
 * Wraps a lambda handler adding it error capture and tracing capabilities.
 *
 * @param handler Handler
 * @param options Options
 * @returns Handler
 */
export declare function wrapHandler<TEvent, TResult>(handler: Handler<TEvent, TResult>, wrapOptions?: Partial<WrapperOptions>): Handler<TEvent, TResult>;
//# sourceMappingURL=sdk.d.ts.map
