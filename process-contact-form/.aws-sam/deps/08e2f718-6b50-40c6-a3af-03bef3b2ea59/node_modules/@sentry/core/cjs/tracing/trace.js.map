{"version":3,"file":"trace.js","sources":["../../../src/tracing/trace.ts"],"sourcesContent":["import type { ClientOptions, Scope, SentrySpanArguments, Span, SpanTimeInput, StartSpanOptions } from '@sentry/types';\nimport { propagationContextFromHeaders } from '@sentry/utils';\nimport type { AsyncContextStrategy } from '../asyncContext/types';\nimport { getMainCarrier } from '../carrier';\n\nimport { getClient, getCurrentScope, getIsolationScope, withScope } from '../currentScopes';\n\nimport { getAsyncContextStrategy } from '../asyncContext';\nimport { SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, SEMANTIC_ATTRIBUTE_SENTRY_SOURCE } from '../semanticAttributes';\nimport { handleCallbackErrors } from '../utils/handleCallbackErrors';\nimport { hasTracingEnabled } from '../utils/hasTracingEnabled';\nimport { _getSpanForScope, _setSpanForScope } from '../utils/spanOnScope';\nimport { addChildSpanToSpan, getRootSpan, spanIsSampled, spanTimeInputToSeconds, spanToJSON } from '../utils/spanUtils';\nimport { freezeDscOnSpan, getDynamicSamplingContextFromSpan } from './dynamicSamplingContext';\nimport { logSpanStart } from './logSpans';\nimport { sampleSpan } from './sampling';\nimport { SentryNonRecordingSpan } from './sentryNonRecordingSpan';\nimport { SentrySpan } from './sentrySpan';\nimport { SPAN_STATUS_ERROR } from './spanstatus';\nimport { setCapturedScopesOnSpan } from './utils';\n\nconst SUPPRESS_TRACING_KEY = '__SENTRY_SUPPRESS_TRACING__';\n\n/**\n * Wraps a function with a transaction/span and finishes the span after the function is done.\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * If you want to create a span that is not set as active, use {@link startInactiveSpan}.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startSpan<T>(context: StartSpanOptions, callback: (span: Span) => T): T {\n  const acs = getAcs();\n  if (acs.startSpan) {\n    return acs.startSpan(context, callback);\n  }\n\n  const spanContext = normalizeContext(context);\n\n  return withScope(context.scope, scope => {\n    const parentSpan = getParentSpan(scope);\n\n    const shouldSkipSpan = context.onlyIfParent && !parentSpan;\n    const activeSpan = shouldSkipSpan\n      ? new SentryNonRecordingSpan()\n      : createChildOrRootSpan({\n          parentSpan,\n          spanContext,\n          forceTransaction: context.forceTransaction,\n          scope,\n        });\n\n    _setSpanForScope(scope, activeSpan);\n\n    return handleCallbackErrors(\n      () => callback(activeSpan),\n      () => {\n        // Only update the span status if it hasn't been changed yet, and the span is not yet finished\n        const { status } = spanToJSON(activeSpan);\n        if (activeSpan.isRecording() && (!status || status === 'ok')) {\n          activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n        }\n      },\n      () => activeSpan.end(),\n    );\n  });\n}\n\n/**\n * Similar to `Sentry.startSpan`. Wraps a function with a transaction/span, but does not finish the span\n * after the function is done automatically. You'll have to call `span.end()` manually.\n *\n * The created span is the active span and will be used as parent by other spans created inside the function\n * and can be accessed via `Sentry.getActiveSpan()`, as long as the function is executed while the scope is active.\n *\n * You'll always get a span passed to the callback,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startSpanManual<T>(context: StartSpanOptions, callback: (span: Span, finish: () => void) => T): T {\n  const acs = getAcs();\n  if (acs.startSpanManual) {\n    return acs.startSpanManual(context, callback);\n  }\n\n  const spanContext = normalizeContext(context);\n\n  return withScope(context.scope, scope => {\n    const parentSpan = getParentSpan(scope);\n\n    const shouldSkipSpan = context.onlyIfParent && !parentSpan;\n    const activeSpan = shouldSkipSpan\n      ? new SentryNonRecordingSpan()\n      : createChildOrRootSpan({\n          parentSpan,\n          spanContext,\n          forceTransaction: context.forceTransaction,\n          scope,\n        });\n\n    _setSpanForScope(scope, activeSpan);\n\n    function finishAndSetSpan(): void {\n      activeSpan.end();\n    }\n\n    return handleCallbackErrors(\n      () => callback(activeSpan, finishAndSetSpan),\n      () => {\n        // Only update the span status if it hasn't been changed yet, and the span is not yet finished\n        const { status } = spanToJSON(activeSpan);\n        if (activeSpan.isRecording() && (!status || status === 'ok')) {\n          activeSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'internal_error' });\n        }\n      },\n    );\n  });\n}\n\n/**\n * Creates a span. This span is not set as active, so will not get automatic instrumentation spans\n * as children or be able to be accessed via `Sentry.getActiveSpan()`.\n *\n * If you want to create a span that is set as active, use {@link startSpan}.\n *\n * This function will always return a span,\n * it may just be a non-recording span if the span is not sampled or if tracing is disabled.\n */\nexport function startInactiveSpan(context: StartSpanOptions): Span {\n  const acs = getAcs();\n  if (acs.startInactiveSpan) {\n    return acs.startInactiveSpan(context);\n  }\n\n  const spanContext = normalizeContext(context);\n\n  const scope = context.scope || getCurrentScope();\n  const parentSpan = getParentSpan(scope);\n\n  const shouldSkipSpan = context.onlyIfParent && !parentSpan;\n\n  if (shouldSkipSpan) {\n    return new SentryNonRecordingSpan();\n  }\n\n  return createChildOrRootSpan({\n    parentSpan,\n    spanContext,\n    forceTransaction: context.forceTransaction,\n    scope,\n  });\n}\n\n/**\n * Continue a trace from `sentry-trace` and `baggage` values.\n * These values can be obtained from incoming request headers, or in the browser from `<meta name=\"sentry-trace\">`\n * and `<meta name=\"baggage\">` HTML tags.\n *\n * Spans started with `startSpan`, `startSpanManual` and `startInactiveSpan`, within the callback will automatically\n * be attached to the incoming trace.\n */\nexport const continueTrace = <V>(\n  {\n    sentryTrace,\n    baggage,\n  }: {\n    sentryTrace: Parameters<typeof propagationContextFromHeaders>[0];\n    baggage: Parameters<typeof propagationContextFromHeaders>[1];\n  },\n  callback: () => V,\n): V => {\n  return withScope(scope => {\n    const propagationContext = propagationContextFromHeaders(sentryTrace, baggage);\n    scope.setPropagationContext(propagationContext);\n    return callback();\n  });\n};\n\n/**\n * Forks the current scope and sets the provided span as active span in the context of the provided callback. Can be\n * passed `null` to start an entirely new span tree.\n *\n * @param span Spans started in the context of the provided callback will be children of this span. If `null` is passed,\n * spans started within the callback will not be attached to a parent span.\n * @param callback Execution context in which the provided span will be active. Is passed the newly forked scope.\n * @returns the value returned from the provided callback function.\n */\nexport function withActiveSpan<T>(span: Span | null, callback: (scope: Scope) => T): T {\n  const acs = getAcs();\n  if (acs.withActiveSpan) {\n    return acs.withActiveSpan(span, callback);\n  }\n\n  return withScope(scope => {\n    _setSpanForScope(scope, span || undefined);\n    return callback(scope);\n  });\n}\n\n/** Suppress tracing in the given callback, ensuring no spans are generated inside of it. */\nexport function suppressTracing<T>(callback: () => T): T {\n  const acs = getAcs();\n\n  if (acs.suppressTracing) {\n    return acs.suppressTracing(callback);\n  }\n\n  return withScope(scope => {\n    scope.setSDKProcessingMetadata({ [SUPPRESS_TRACING_KEY]: true });\n    return callback();\n  });\n}\n\nfunction createChildOrRootSpan({\n  parentSpan,\n  spanContext,\n  forceTransaction,\n  scope,\n}: {\n  parentSpan: SentrySpan | undefined;\n  spanContext: SentrySpanArguments;\n  forceTransaction?: boolean;\n  scope: Scope;\n}): Span {\n  if (!hasTracingEnabled()) {\n    return new SentryNonRecordingSpan();\n  }\n\n  const isolationScope = getIsolationScope();\n\n  let span: Span;\n  if (parentSpan && !forceTransaction) {\n    span = _startChildSpan(parentSpan, scope, spanContext);\n    addChildSpanToSpan(parentSpan, span);\n  } else if (parentSpan) {\n    // If we forced a transaction but have a parent span, make sure to continue from the parent span, not the scope\n    const dsc = getDynamicSamplingContextFromSpan(parentSpan);\n    const { traceId, spanId: parentSpanId } = parentSpan.spanContext();\n    const parentSampled = spanIsSampled(parentSpan);\n\n    span = _startRootSpan(\n      {\n        traceId,\n        parentSpanId,\n        ...spanContext,\n      },\n      scope,\n      parentSampled,\n    );\n\n    freezeDscOnSpan(span, dsc);\n  } else {\n    const {\n      traceId,\n      dsc,\n      parentSpanId,\n      sampled: parentSampled,\n    } = {\n      ...isolationScope.getPropagationContext(),\n      ...scope.getPropagationContext(),\n    };\n\n    span = _startRootSpan(\n      {\n        traceId,\n        parentSpanId,\n        ...spanContext,\n      },\n      scope,\n      parentSampled,\n    );\n\n    if (dsc) {\n      freezeDscOnSpan(span, dsc);\n    }\n  }\n\n  logSpanStart(span);\n\n  setCapturedScopesOnSpan(span, scope, isolationScope);\n\n  return span;\n}\n\n/**\n * This converts StartSpanOptions to SentrySpanArguments.\n * For the most part (for now) we accept the same options,\n * but some of them need to be transformed.\n *\n * Eventually the StartSpanOptions will be more aligned with OpenTelemetry.\n */\nfunction normalizeContext(context: StartSpanOptions): SentrySpanArguments {\n  const exp = context.experimental || {};\n  const initialCtx: SentrySpanArguments = {\n    isStandalone: exp.standalone,\n    ...context,\n  };\n\n  if (context.startTime) {\n    const ctx: SentrySpanArguments & { startTime?: SpanTimeInput } = { ...initialCtx };\n    ctx.startTimestamp = spanTimeInputToSeconds(context.startTime);\n    delete ctx.startTime;\n    return ctx;\n  }\n\n  return initialCtx;\n}\n\nfunction getAcs(): AsyncContextStrategy {\n  const carrier = getMainCarrier();\n  return getAsyncContextStrategy(carrier);\n}\n\nfunction _startRootSpan(spanArguments: SentrySpanArguments, scope: Scope, parentSampled?: boolean): SentrySpan {\n  const client = getClient();\n  const options: Partial<ClientOptions> = (client && client.getOptions()) || {};\n\n  const { name = '', attributes } = spanArguments;\n  const [sampled, sampleRate] = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY]\n    ? [false]\n    : sampleSpan(options, {\n        name,\n        parentSampled,\n        attributes,\n        transactionContext: {\n          name,\n          parentSampled,\n        },\n      });\n\n  const rootSpan = new SentrySpan({\n    ...spanArguments,\n    attributes: {\n      [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'custom',\n      ...spanArguments.attributes,\n    },\n    sampled,\n  });\n  if (sampleRate !== undefined) {\n    rootSpan.setAttribute(SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE, sampleRate);\n  }\n\n  if (client) {\n    client.emit('spanStart', rootSpan);\n  }\n\n  return rootSpan;\n}\n\n/**\n * Creates a new `Span` while setting the current `Span.id` as `parentSpanId`.\n * This inherits the sampling decision from the parent span.\n */\nfunction _startChildSpan(parentSpan: Span, scope: Scope, spanArguments: SentrySpanArguments): Span {\n  const { spanId, traceId } = parentSpan.spanContext();\n  const sampled = scope.getScopeData().sdkProcessingMetadata[SUPPRESS_TRACING_KEY] ? false : spanIsSampled(parentSpan);\n\n  const childSpan = sampled\n    ? new SentrySpan({\n        ...spanArguments,\n        parentSpanId: spanId,\n        traceId,\n        sampled,\n      })\n    : new SentryNonRecordingSpan({ traceId });\n\n  addChildSpanToSpan(parentSpan, childSpan);\n\n  const client = getClient();\n  if (client) {\n    client.emit('spanStart', childSpan);\n    // If it has an endTimestamp, it's already ended\n    if (spanArguments.endTimestamp) {\n      client.emit('spanEnd', childSpan);\n    }\n  }\n\n  return childSpan;\n}\n\nfunction getParentSpan(scope: Scope): SentrySpan | undefined {\n  const span = _getSpanForScope(scope) as SentrySpan | undefined;\n\n  if (!span) {\n    return undefined;\n  }\n\n  const client = getClient();\n  const options: Partial<ClientOptions> = client ? client.getOptions() : {};\n  if (options.parentSpanIsAlwaysRootSpan) {\n    return getRootSpan(span) as SentrySpan;\n  }\n\n  return span;\n}\n"],"names":["withScope","SentryNonRecordingSpan","_setSpanForScope","handleCallbackErrors","spanToJSON","SPAN_STATUS_ERROR","getCurrentScope","propagationContextFromHeaders","hasTracingEnabled","getIsolationScope","addChildSpanToSpan","getDynamicSamplingContextFromSpan","spanIsSampled","freezeDscOnSpan","logSpanStart","setCapturedScopesOnSpan","spanTimeInputToSeconds","carrier","getMainCarrier","getAsyncContextStrategy","getClient","sampleSpan","SentrySpan","SEMANTIC_ATTRIBUTE_SENTRY_SOURCE","SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE","_getSpanForScope","getRootSpan"],"mappings":"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"}