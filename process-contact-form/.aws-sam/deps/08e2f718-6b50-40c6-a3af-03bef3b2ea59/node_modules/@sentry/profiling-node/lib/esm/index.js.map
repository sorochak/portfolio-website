{"version":3,"file":"index.js","sources":["../../src/debug-build.ts","../../src/cpu_profiler.ts","../../src/utils.ts","../../src/spanProfileUtils.ts","../../src/integration.ts"],"sourcesContent":["declare const __DEBUG_BUILD__: boolean;\n\n/**\n * This serves as a build time flag that will be true by default, but false in non-debug builds or if users replace `__SENTRY_DEBUG__` in their generated code.\n *\n * ATTENTION: This constant must never cross package boundaries (i.e. be exported) to guarantee that it can be used for tree shaking.\n */\nexport const DEBUG_BUILD = __DEBUG_BUILD__;\n","import { arch as _arch, platform as _platform } from 'os';\nimport { join, resolve } from 'path';\nimport { familySync } from 'detect-libc';\nimport { getAbi } from 'node-abi';\nimport { env, versions } from 'process';\nimport { threadId } from 'worker_threads';\n\nimport { GLOBAL_OBJ, logger } from '@sentry/utils';\nimport { DEBUG_BUILD } from './debug-build';\nimport type { PrivateV8CpuProfilerBindings, V8CpuProfilerBindings } from './types';\n\nconst stdlib = familySync();\nconst platform = process.env['BUILD_PLATFORM'] || _platform();\nconst arch = process.env['BUILD_ARCH'] || _arch();\nconst abi = getAbi(versions.node, 'node');\nconst identifier = [platform, arch, stdlib, abi].filter(c => c !== undefined && c !== null).join('-');\n\nconst built_from_source_path = resolve(__dirname, '..', `./sentry_cpu_profiler-${identifier}`);\n\n/**\n *  Imports cpp bindings based on the current platform and architecture.\n */\n// eslint-disable-next-line complexity\nexport function importCppBindingsModule(): PrivateV8CpuProfilerBindings {\n  // If a binary path is specified, use that.\n  if (env['SENTRY_PROFILER_BINARY_PATH']) {\n    const envPath = env['SENTRY_PROFILER_BINARY_PATH'];\n    return require(envPath);\n  }\n\n  // If a user specifies a different binary dir, they are in control of the binaries being moved there\n  if (env['SENTRY_PROFILER_BINARY_DIR']) {\n    const binaryPath = join(resolve(env['SENTRY_PROFILER_BINARY_DIR']), `sentry_cpu_profiler-${identifier}`);\n    return require(`${binaryPath}.node`);\n  }\n\n  // We need the fallthrough so that in the end, we can fallback to the require dynamice require.\n  // This is for cases where precompiled binaries were not provided, but may have been compiled from source.\n  if (platform === 'darwin') {\n    if (arch === 'x64') {\n      if (abi === '93') {\n        return require('../sentry_cpu_profiler-darwin-x64-93.node');\n      }\n      if (abi === '108') {\n        return require('../sentry_cpu_profiler-darwin-x64-108.node');\n      }\n      if (abi === '115') {\n        return require('../sentry_cpu_profiler-darwin-x64-115.node');\n      }\n      if (abi === '127') {\n        return require('../sentry_cpu_profiler-darwin-x64-127.node');\n      }\n    }\n\n    if (arch === 'arm64') {\n      if (abi === '93') {\n        return require('../sentry_cpu_profiler-darwin-arm64-93.node');\n      }\n      if (abi === '108') {\n        return require('../sentry_cpu_profiler-darwin-arm64-108.node');\n      }\n      if (abi === '115') {\n        return require('../sentry_cpu_profiler-darwin-arm64-115.node');\n      }\n      if (abi === '127') {\n        return require('../sentry_cpu_profiler-darwin-arm64-127.node');\n      }\n    }\n  }\n\n  if (platform === 'win32') {\n    if (arch === 'x64') {\n      if (abi === '93') {\n        return require('../sentry_cpu_profiler-win32-x64-93.node');\n      }\n      if (abi === '108') {\n        return require('../sentry_cpu_profiler-win32-x64-108.node');\n      }\n      if (abi === '115') {\n        return require('../sentry_cpu_profiler-win32-x64-115.node');\n      }\n      if (abi === '127') {\n        return require('../sentry_cpu_profiler-win32-x64-127.node');\n      }\n    }\n  }\n\n  if (platform === 'linux') {\n    if (arch === 'x64') {\n      if (stdlib === 'musl') {\n        if (abi === '93') {\n          return require('../sentry_cpu_profiler-linux-x64-musl-93.node');\n        }\n        if (abi === '108') {\n          return require('../sentry_cpu_profiler-linux-x64-musl-108.node');\n        }\n        if (abi === '115') {\n          return require('../sentry_cpu_profiler-linux-x64-musl-115.node');\n        }\n        if (abi === '127') {\n          return require('../sentry_cpu_profiler-linux-x64-musl-127.node');\n        }\n      }\n      if (stdlib === 'glibc') {\n        if (abi === '93') {\n          return require('../sentry_cpu_profiler-linux-x64-glibc-93.node');\n        }\n        if (abi === '108') {\n          return require('../sentry_cpu_profiler-linux-x64-glibc-108.node');\n        }\n        if (abi === '115') {\n          return require('../sentry_cpu_profiler-linux-x64-glibc-115.node');\n        }\n        if (abi === '127') {\n          return require('../sentry_cpu_profiler-linux-x64-glibc-127.node');\n        }\n      }\n    }\n    if (arch === 'arm64') {\n      if (stdlib === 'musl') {\n        if (abi === '93') {\n          return require('../sentry_cpu_profiler-linux-arm64-musl-93.node');\n        }\n        if (abi === '108') {\n          return require('../sentry_cpu_profiler-linux-arm64-musl-108.node');\n        }\n        if (abi === '115') {\n          return require('../sentry_cpu_profiler-linux-arm64-musl-115.node');\n        }\n        if (abi === '127') {\n          return require('../sentry_cpu_profiler-linux-arm64-musl-127.node');\n        }\n      }\n      if (stdlib === 'glibc') {\n        if (abi === '93') {\n          return require('../sentry_cpu_profiler-linux-arm64-glibc-93.node');\n        }\n        if (abi === '108') {\n          return require('../sentry_cpu_profiler-linux-arm64-glibc-108.node');\n        }\n        if (abi === '115') {\n          return require('../sentry_cpu_profiler-linux-arm64-glibc-115.node');\n        }\n        if (abi === '127') {\n          return require('../sentry_cpu_profiler-linux-arm64-glibc-127.node');\n        }\n      }\n    }\n  }\n  return require(`${built_from_source_path}.node`);\n}\n\nconst PrivateCpuProfilerBindings: PrivateV8CpuProfilerBindings = importCppBindingsModule();\nconst CpuProfilerBindings: V8CpuProfilerBindings = {\n  startProfiling(name: string) {\n    if (!PrivateCpuProfilerBindings) {\n      DEBUG_BUILD && logger.log('[Profiling] Bindings not loaded, ignoring call to startProfiling.');\n      return;\n    }\n\n    return PrivateCpuProfilerBindings.startProfiling(name);\n  },\n  stopProfiling(name: string) {\n    if (!PrivateCpuProfilerBindings) {\n      DEBUG_BUILD &&\n        logger.log('[Profiling] Bindings not loaded or profile was never started, ignoring call to stopProfiling.');\n      return null;\n    }\n    return PrivateCpuProfilerBindings.stopProfiling(name, threadId, !!GLOBAL_OBJ._sentryDebugIds);\n  },\n};\n\nexport { PrivateCpuProfilerBindings };\nexport { CpuProfilerBindings };\n","import * as os from 'os';\nimport type { Client, Context, Envelope, Event, StackFrame, StackParser } from '@sentry/types';\nimport { env, versions } from 'process';\nimport { isMainThread, threadId } from 'worker_threads';\n\nimport { GLOBAL_OBJ, forEachEnvelopeItem, logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from './debug-build';\nimport type { Profile, RawThreadCpuProfile, ThreadCpuProfile } from './types';\nimport type { DebugImage } from './types';\n\n// We require the file because if we import it, it will be included in the bundle.\n// I guess tsc does not check file contents when it's imported.\nconst THREAD_ID_STRING = String(threadId);\nconst THREAD_NAME = isMainThread ? 'main' : 'worker';\nconst FORMAT_VERSION = '1';\n\n// Os machine was backported to 16.18, but this was not reflected in the types\n// @ts-expect-error ignore missing\nconst machine = typeof os.machine === 'function' ? os.machine() : os.arch();\n\n// Machine properties (eval only once)\nconst PLATFORM = os.platform();\nconst RELEASE = os.release();\nconst VERSION = os.version();\nconst TYPE = os.type();\nconst MODEL = machine;\nconst ARCH = os.arch();\n\n/**\n * Checks if the profile is a raw profile or a profile enriched with thread information.\n * @param {ThreadCpuProfile | RawThreadCpuProfile} profile\n * @returns {boolean}\n */\nfunction isRawThreadCpuProfile(profile: ThreadCpuProfile | RawThreadCpuProfile): profile is RawThreadCpuProfile {\n  return !('thread_metadata' in profile);\n}\n\n/**\n * Enriches the profile with threadId of the current thread.\n * This is done in node as we seem to not be able to get the info from C native code.\n *\n * @param {ThreadCpuProfile | RawThreadCpuProfile} profile\n * @returns {ThreadCpuProfile}\n */\nexport function enrichWithThreadInformation(profile: ThreadCpuProfile | RawThreadCpuProfile): ThreadCpuProfile {\n  if (!isRawThreadCpuProfile(profile)) {\n    return profile;\n  }\n\n  return {\n    samples: profile.samples,\n    frames: profile.frames,\n    stacks: profile.stacks,\n    thread_metadata: {\n      [THREAD_ID_STRING]: {\n        name: THREAD_NAME,\n      },\n    },\n  };\n}\n\n/**\n * Creates a profiling envelope item, if the profile does not pass validation, returns null.\n * @param {RawThreadCpuProfile}\n * @param {Event}\n * @returns {Profile | null}\n */\nexport function createProfilingEvent(client: Client, profile: RawThreadCpuProfile, event: Event): Profile | null {\n  if (!isValidProfile(profile)) {\n    return null;\n  }\n\n  return createProfilePayload(client, profile, {\n    release: event.release ?? '',\n    environment: event.environment ?? '',\n    event_id: event.event_id ?? '',\n    transaction: event.transaction ?? '',\n    start_timestamp: event.start_timestamp ? event.start_timestamp * 1000 : Date.now(),\n    trace_id: event.contexts?.['trace']?.['trace_id'] ?? '',\n    profile_id: profile.profile_id,\n  });\n}\n\n/**\n * Create a profile\n * @param {RawThreadCpuProfile} cpuProfile\n * @param {options}\n * @returns {Profile}\n */\n\nfunction createProfilePayload(\n  client: Client,\n  cpuProfile: RawThreadCpuProfile,\n  {\n    release,\n    environment,\n    event_id,\n    transaction,\n    start_timestamp,\n    trace_id,\n    profile_id,\n  }: {\n    release: string;\n    environment: string;\n    event_id: string;\n    transaction: string;\n    start_timestamp: number;\n    trace_id: string | undefined;\n    profile_id: string;\n  },\n): Profile {\n  // Log a warning if the profile has an invalid traceId (should be uuidv4).\n  // All profiles and transactions are rejected if this is the case and we want to\n  // warn users that this is happening if they enable debug flag\n  if (trace_id && trace_id.length !== 32) {\n    DEBUG_BUILD && logger.log(`[Profiling] Invalid traceId: ${trace_id} on profiled event`);\n  }\n\n  const enrichedThreadProfile = enrichWithThreadInformation(cpuProfile);\n\n  const profile: Profile = {\n    event_id: profile_id,\n    timestamp: new Date(start_timestamp).toISOString(),\n    platform: 'node',\n    version: FORMAT_VERSION,\n    release: release,\n    environment: environment,\n    measurements: cpuProfile.measurements,\n    runtime: {\n      name: 'node',\n      version: versions.node || '',\n    },\n    os: {\n      name: PLATFORM,\n      version: RELEASE,\n      build_number: VERSION,\n    },\n    device: {\n      locale: env['LC_ALL'] || env['LC_MESSAGES'] || env['LANG'] || env['LANGUAGE'] || '',\n      model: MODEL,\n      manufacturer: TYPE,\n      architecture: ARCH,\n      is_emulator: false,\n    },\n    debug_meta: {\n      images: applyDebugMetadata(client, cpuProfile.resources),\n    },\n    profile: enrichedThreadProfile,\n    transaction: {\n      name: transaction,\n      id: event_id,\n      trace_id: trace_id || '',\n      active_thread_id: THREAD_ID_STRING,\n    },\n  };\n\n  return profile;\n}\n\n/**\n * Checks the given sample rate to make sure it is valid type and value (a boolean, or a number between 0 and 1).\n * @param {unknown} rate\n * @returns {boolean}\n */\nexport function isValidSampleRate(rate: unknown): boolean {\n  // we need to check NaN explicitly because it's of type 'number' and therefore wouldn't get caught by this typecheck\n  if ((typeof rate !== 'number' && typeof rate !== 'boolean') || (typeof rate === 'number' && isNaN(rate))) {\n    DEBUG_BUILD &&\n      logger.warn(\n        `[Profiling] Invalid sample rate. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(\n          rate,\n        )} of type ${JSON.stringify(typeof rate)}.`,\n      );\n    return false;\n  }\n\n  // Boolean sample rates are always valid\n  if (rate === true || rate === false) {\n    return true;\n  }\n\n  // in case sampleRate is a boolean, it will get automatically cast to 1 if it's true and 0 if it's false\n  if (rate < 0 || rate > 1) {\n    DEBUG_BUILD && logger.warn(`[Profiling] Invalid sample rate. Sample rate must be between 0 and 1. Got ${rate}.`);\n    return false;\n  }\n  return true;\n}\n\n/**\n * Checks if the profile is valid and can be sent to Sentry.\n * @param {RawThreadCpuProfile} profile\n * @returns {boolean}\n */\nexport function isValidProfile(profile: RawThreadCpuProfile): profile is RawThreadCpuProfile & { profile_id: string } {\n  if (profile.samples.length <= 1) {\n    DEBUG_BUILD &&\n      // Log a warning if the profile has less than 2 samples so users can know why\n      // they are not seeing any profiling data and we cant avoid the back and forth\n      // of asking them to provide us with a dump of the profile data.\n      logger.log('[Profiling] Discarding profile because it contains less than 2 samples');\n    return false;\n  }\n\n  if (!profile.profile_id) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Adds items to envelope if they are not already present - mutates the envelope.\n * @param {Envelope} envelope\n * @param {Profile[]} profiles\n * @returns {Envelope}\n */\nexport function addProfilesToEnvelope(envelope: Envelope, profiles: Profile[]): Envelope {\n  if (!profiles.length) {\n    return envelope;\n  }\n\n  for (const profile of profiles) {\n    // @ts-expect-error untyped envelope\n    envelope[1].push([{ type: 'profile' }, profile]);\n  }\n  return envelope;\n}\n\n/**\n * Finds transactions with profile_id context in the envelope\n * @param {Envelope} envelope\n * @returns {Event[]}\n */\nexport function findProfiledTransactionsFromEnvelope(envelope: Envelope): Event[] {\n  const events: Event[] = [];\n\n  forEachEnvelopeItem(envelope, (item, type) => {\n    if (type !== 'transaction') {\n      return;\n    }\n\n    // First item is the type, so we can skip it, everything else is an event\n    for (let j = 1; j < item.length; j++) {\n      const event = item[j];\n\n      if (!event) {\n        // Shouldnt happen, but lets be safe\n        continue;\n      }\n\n      // @ts-expect-error profile_id is not part of the metadata type\n      const profile_id = (event.contexts as Context)?.['profile']?.['profile_id'];\n\n      if (event && profile_id) {\n        events.push(item[j] as Event);\n      }\n    }\n  });\n\n  return events;\n}\n\nconst debugIdStackParserCache = new WeakMap<StackParser, Map<string, StackFrame[]>>();\n\n/**\n * Cross reference profile collected resources with debug_ids and return a list of debug images.\n * @param {string[]} resource_paths\n * @returns {DebugImage[]}\n */\nexport function applyDebugMetadata(client: Client, resource_paths: ReadonlyArray<string>): DebugImage[] {\n  const debugIdMap = GLOBAL_OBJ._sentryDebugIds;\n  if (!debugIdMap) {\n    return [];\n  }\n\n  const options = client.getOptions();\n\n  if (!options || !options.stackParser) {\n    return [];\n  }\n\n  let debugIdStackFramesCache: Map<string, StackFrame[]>;\n  const cachedDebugIdStackFrameCache = debugIdStackParserCache.get(options.stackParser);\n  if (cachedDebugIdStackFrameCache) {\n    debugIdStackFramesCache = cachedDebugIdStackFrameCache;\n  } else {\n    debugIdStackFramesCache = new Map<string, StackFrame[]>();\n    debugIdStackParserCache.set(options.stackParser, debugIdStackFramesCache);\n  }\n\n  // Build a map of filename -> debug_id.\n  const filenameDebugIdMap = Object.keys(debugIdMap).reduce<Record<string, string>>((acc, debugIdStackTrace) => {\n    let parsedStack: StackFrame[];\n\n    const cachedParsedStack = debugIdStackFramesCache.get(debugIdStackTrace);\n    if (cachedParsedStack) {\n      parsedStack = cachedParsedStack;\n    } else {\n      parsedStack = options.stackParser(debugIdStackTrace);\n      debugIdStackFramesCache.set(debugIdStackTrace, parsedStack);\n    }\n\n    for (let i = parsedStack.length - 1; i >= 0; i--) {\n      const stackFrame = parsedStack[i];\n      const file = stackFrame && stackFrame.filename;\n\n      if (stackFrame && file) {\n        acc[file] = debugIdMap[debugIdStackTrace] as string;\n        break;\n      }\n    }\n    return acc;\n  }, {});\n\n  const images: DebugImage[] = [];\n\n  for (const resource of resource_paths) {\n    if (resource && filenameDebugIdMap[resource]) {\n      images.push({\n        type: 'sourcemap',\n        code_file: resource,\n        debug_id: filenameDebugIdMap[resource] as string,\n      });\n    }\n  }\n\n  return images;\n}\n","import { spanIsSampled, spanToJSON } from '@sentry/core';\nimport type { NodeClient } from '@sentry/node';\nimport type { CustomSamplingContext, Span } from '@sentry/types';\nimport { logger, uuid4 } from '@sentry/utils';\n\nimport { CpuProfilerBindings } from './cpu_profiler';\nimport { DEBUG_BUILD } from './debug-build';\nimport { isValidSampleRate } from './utils';\n\nexport const MAX_PROFILE_DURATION_MS = 30 * 1000;\n\n/**\n * Takes a transaction and determines if it should be profiled or not. If it should be profiled, it returns the\n * profile_id, otherwise returns undefined. Takes care of setting profile context on transaction as well\n */\nexport function maybeProfileSpan(\n  client: NodeClient | undefined,\n  span: Span,\n  customSamplingContext?: CustomSamplingContext,\n): string | undefined {\n  // profilesSampleRate is multiplied with tracesSampleRate to get the final sampling rate. We dont perform\n  // the actual multiplication to get the final rate, but we discard the profile if the span was sampled,\n  // so anything after this block from here is based on the span sampling.\n  if (!spanIsSampled(span)) {\n    return;\n  }\n\n  // Client and options are required for profiling\n  if (!client) {\n    DEBUG_BUILD && logger.log('[Profiling] Profiling disabled, no client found.');\n    return;\n  }\n\n  const options = client.getOptions();\n  if (!options) {\n    DEBUG_BUILD && logger.log('[Profiling] Profiling disabled, no options found.');\n    return;\n  }\n\n  const profilesSampler = options.profilesSampler;\n  let profilesSampleRate: number | boolean | undefined = options.profilesSampleRate;\n\n  // Prefer sampler to sample rate if both are provided.\n  if (typeof profilesSampler === 'function') {\n    const { description: spanName = '<unknown>', data } = spanToJSON(span);\n    // We bail out early if that is not the case\n    const parentSampled = true;\n\n    profilesSampleRate = profilesSampler({\n      name: spanName,\n      attributes: data,\n      transactionContext: {\n        name: spanName,\n        parentSampled,\n      },\n      parentSampled,\n      ...customSamplingContext,\n    });\n  }\n\n  // Since this is coming from the user (or from a function provided by the user), who knows what we might get. (The\n  // only valid values are booleans or numbers between 0 and 1.)\n  if (!isValidSampleRate(profilesSampleRate)) {\n    DEBUG_BUILD && logger.warn('[Profiling] Discarding profile because of invalid sample rate.');\n    return;\n  }\n\n  // if the function returned 0 (or false), or if `profileSampleRate` is 0, it's a sign the profile should be dropped\n  if (!profilesSampleRate) {\n    DEBUG_BUILD &&\n      logger.log(\n        `[Profiling] Discarding profile because ${\n          typeof profilesSampler === 'function'\n            ? 'profileSampler returned 0 or false'\n            : 'a negative sampling decision was inherited or profileSampleRate is set to 0'\n        }`,\n      );\n    return;\n  }\n\n  // Now we roll the dice. Math.random is inclusive of 0, but not of 1, so strict < is safe here. In case sampleRate is\n  // a boolean, the < comparison will cause it to be automatically cast to 1 if it's true and 0 if it's false.\n  const sampled = profilesSampleRate === true ? true : Math.random() < profilesSampleRate;\n  // Check if we should sample this profile\n  if (!sampled) {\n    DEBUG_BUILD &&\n      logger.log(\n        `[Profiling] Discarding profile because it's not included in the random sample (sampling rate = ${Number(\n          profilesSampleRate,\n        )})`,\n      );\n    return;\n  }\n\n  const profile_id = uuid4();\n  CpuProfilerBindings.startProfiling(profile_id);\n  DEBUG_BUILD && logger.log(`[Profiling] started profiling transaction: ${spanToJSON(span).description}`);\n\n  // set transaction context - do this regardless if profiling fails down the line\n  // so that we can still see the profile_id in the transaction context\n  return profile_id;\n}\n\n/**\n * Stops the profiler for profile_id and returns the profile\n * @param transaction\n * @param profile_id\n * @returns\n */\nexport function stopSpanProfile(\n  span: Span,\n  profile_id: string | undefined,\n): ReturnType<(typeof CpuProfilerBindings)['stopProfiling']> | null {\n  // Should not happen, but satisfy the type checker and be safe regardless.\n  if (!profile_id) {\n    return null;\n  }\n\n  const profile = CpuProfilerBindings.stopProfiling(profile_id);\n\n  DEBUG_BUILD && logger.log(`[Profiling] stopped profiling of transaction: ${spanToJSON(span).description}`);\n\n  // In case of an overlapping span, stopProfiling may return null and silently ignore the overlapping profile.\n  if (!profile) {\n    DEBUG_BUILD &&\n      logger.log(\n        `[Profiling] profiler returned null profile for: ${spanToJSON(span).description}`,\n        'this may indicate an overlapping span or a call to stopProfiling with a profile title that was never started',\n      );\n    return null;\n  }\n\n  // Assign profile_id to the profile\n  profile.profile_id = profile_id;\n  return profile;\n}\n","import { defineIntegration, getCurrentScope, getRootSpan, spanToJSON } from '@sentry/core';\nimport type { NodeClient } from '@sentry/node';\nimport type { IntegrationFn, Span } from '@sentry/types';\n\nimport { logger } from '@sentry/utils';\n\nimport { DEBUG_BUILD } from './debug-build';\nimport { MAX_PROFILE_DURATION_MS, maybeProfileSpan, stopSpanProfile } from './spanProfileUtils';\nimport type { Profile, RawThreadCpuProfile } from './types';\n\nimport { addProfilesToEnvelope, createProfilingEvent, findProfiledTransactionsFromEnvelope } from './utils';\n\nconst MAX_PROFILE_QUEUE_LENGTH = 50;\nconst PROFILE_QUEUE: RawThreadCpuProfile[] = [];\nconst PROFILE_TIMEOUTS: Record<string, NodeJS.Timeout> = {};\n\nfunction addToProfileQueue(profile: RawThreadCpuProfile): void {\n  PROFILE_QUEUE.push(profile);\n\n  // We only want to keep the last n profiles in the queue.\n  if (PROFILE_QUEUE.length > MAX_PROFILE_QUEUE_LENGTH) {\n    PROFILE_QUEUE.shift();\n  }\n}\n\n/** Exported only for tests. */\nexport const _nodeProfilingIntegration = (() => {\n  return {\n    name: 'ProfilingIntegration',\n    setup(client: NodeClient) {\n      const spanToProfileIdMap = new WeakMap<Span, string>();\n\n      client.on('spanStart', span => {\n        if (span !== getRootSpan(span)) {\n          return;\n        }\n\n        const profile_id = maybeProfileSpan(client, span, undefined);\n\n        if (profile_id) {\n          const options = client.getOptions();\n          // Not intended for external use, hence missing types, but we want to profile a couple of things at Sentry that\n          // currently exceed the default timeout set by the SDKs.\n          const maxProfileDurationMs =\n            (options._experiments && options._experiments['maxProfileDurationMs']) || MAX_PROFILE_DURATION_MS;\n\n          if (PROFILE_TIMEOUTS[profile_id]) {\n            global.clearTimeout(PROFILE_TIMEOUTS[profile_id]);\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete PROFILE_TIMEOUTS[profile_id];\n          }\n\n          // Enqueue a timeout to prevent profiles from running over max duration.\n          PROFILE_TIMEOUTS[profile_id] = global.setTimeout(() => {\n            DEBUG_BUILD &&\n              logger.log(\n                '[Profiling] max profile duration elapsed, stopping profiling for:',\n                spanToJSON(span).description,\n              );\n\n            const profile = stopSpanProfile(span, profile_id);\n            if (profile) {\n              addToProfileQueue(profile);\n            }\n          }, maxProfileDurationMs);\n\n          getCurrentScope().setContext('profile', { profile_id });\n\n          spanToProfileIdMap.set(span, profile_id);\n        }\n      });\n\n      client.on('spanEnd', span => {\n        const profile_id = spanToProfileIdMap.get(span);\n\n        if (profile_id) {\n          if (PROFILE_TIMEOUTS[profile_id]) {\n            global.clearTimeout(PROFILE_TIMEOUTS[profile_id]);\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete PROFILE_TIMEOUTS[profile_id];\n          }\n          const profile = stopSpanProfile(span, profile_id);\n\n          if (profile) {\n            addToProfileQueue(profile);\n          }\n        }\n      });\n\n      client.on('beforeEnvelope', (envelope): void => {\n        // if not profiles are in queue, there is nothing to add to the envelope.\n        if (!PROFILE_QUEUE.length) {\n          return;\n        }\n\n        const profiledTransactionEvents = findProfiledTransactionsFromEnvelope(envelope);\n        if (!profiledTransactionEvents.length) {\n          return;\n        }\n\n        const profilesToAddToEnvelope: Profile[] = [];\n\n        for (const profiledTransaction of profiledTransactionEvents) {\n          const profileContext = profiledTransaction.contexts?.['profile'];\n          const profile_id = profileContext?.['profile_id'];\n\n          if (!profile_id) {\n            throw new TypeError('[Profiling] cannot find profile for a transaction without a profile context');\n          }\n\n          // Remove the profile from the transaction context before sending, relay will take care of the rest.\n          if (profileContext) {\n            delete profiledTransaction.contexts?.['profile'];\n          }\n\n          // We need to find both a profile and a transaction event for the same profile_id.\n          const profileIndex = PROFILE_QUEUE.findIndex(p => p.profile_id === profile_id);\n          if (profileIndex === -1) {\n            DEBUG_BUILD && logger.log(`[Profiling] Could not retrieve profile for transaction: ${profile_id}`);\n            continue;\n          }\n\n          const cpuProfile = PROFILE_QUEUE[profileIndex];\n          if (!cpuProfile) {\n            DEBUG_BUILD && logger.log(`[Profiling] Could not retrieve profile for transaction: ${profile_id}`);\n            continue;\n          }\n\n          // Remove the profile from the queue.\n          PROFILE_QUEUE.splice(profileIndex, 1);\n          const profile = createProfilingEvent(client, cpuProfile, profiledTransaction);\n\n          if (client.emit && profile) {\n            const integrations =\n              client['_integrations'] && client['_integrations'] !== null && !Array.isArray(client['_integrations'])\n                ? Object.keys(client['_integrations'])\n                : undefined;\n\n            // @ts-expect-error bad overload due to unknown event\n            client.emit('preprocessEvent', profile, {\n              event_id: profiledTransaction.event_id,\n              integrations,\n            });\n          }\n\n          if (profile) {\n            profilesToAddToEnvelope.push(profile);\n          }\n        }\n\n        addProfilesToEnvelope(envelope, profilesToAddToEnvelope);\n      });\n    },\n  };\n}) satisfies IntegrationFn;\n\n/**\n * We need this integration in order to send data to Sentry. We hook into the event processor\n * and inspect each event to see if it is a transaction event and if that transaction event\n * contains a profile on it's metadata. If that is the case, we create a profiling event envelope\n * and delete the profile from the transaction metadata.\n */\nexport const nodeProfilingIntegration = defineIntegration(_nodeProfilingIntegration);\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;;;AAGO;;ACIP;AACA;AACA;AACA;AACA;;AAEA;;AAE4F;;;AAGA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;;AAEA;;AC1K5F;AAWA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACE;AACF;;AAEA;;AAEA;AACA;;;;AAIO;AACL;;AAEA;;AAEA;;AAEE;AACA;AACA;AACE;AACE;;;;AAIR;;AAEA;AACA;;;;;AAKO;;;AAGL;;AAEA;;;;;AAKE;AACA;;AAEJ;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACE;;AAEA;AACE;;AAEA;;AAEA;AACA;;AAED;;AAQD;AACF;;AAEA;;AAEE;AACE;AACF;;AAEA;;;AAGE;;AAEA;;AAEA;;AAEA;AACA;;;;AAIA;;AAEE;AACA;;AAEF;AACE;;AAEA;AACA;AACA;;;;;;;AAOA;;AAEA;AACA;;;;;AAKN;;AAEA;AACA;AACA;AACA;;AAEO;;AAEL;;;;;AAKF;;;AAGE;;AAEF;;;AAGE;;AAEF;AACE;;;AAGA;;AAEF;;AAEA;;AAEA;AACA;;AAEO;;;;AAIP;;AAEM;;AAEJ;;;;AAIA;;;AAGF;;AAEA;AACA;;;AAGA;;AAEO;AACL;AACE;AACF;;;AAGF;AACI;AACF;AACA;AACF;;AAEA;;;AAGA;;AAEO;AACL;;AAEA;;AAEI;AACF;;;;AAIE;;;;AAIE;AACF;;;;;AAKA;AACE;AACF;AACF;AACJ;;;AAGA;;AAEA;;AAEA;AACA;AACA;;;AAGO;AACL;AACA;AACE;AACF;;AAEA;;AAEA;AACE;AACF;;;AAGA;AACA;;;AAGE;AACA;AACF;;AAEF;AACE;AACE;;AAEA;AACA;;;;;AAKA;;AAEA;AACE;AACA;;AAEA;AACE;;AAEF;AACF;AACA;;;AAGF;;AAEA;AACE;;AAEI;AACA;AACA;AACR;AACI;AACF;;;AAGF;;AChUO;;AAEP;AACA;AACA;;AAEO;AACL;;AAEA;AACF;AACA;AACA;;;AAGI;AACF;;AAEF;;AAEI;AACA;AACF;;AAEA;;AAEE;AACA;AACF;;AAEA;;;AAGF;AACE;;AAEF;;;AAGI;;AAEE;AACA;;;;;;AAMN;AACE;;AAEF;;AAEE;AACE;AACA;AACF;;;;;;AAMM;AACE;AACV;AACA;AACA;;AAES;AACA;;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;;;AAGA;AACA;;;;;;AAMA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;;AAGA;;AAEA;;AAEA;;;;;;AAMA;;;;AAIA;AACA;;;AAGA;;;;;AAKA;;AC3HT;AACA;AACA;;AAEA;;;AAGA;;AAEI;AACF;AACF;;AAEA;AACO;AACL;;;AAGI;;;;AAII;AACF;;;;AAIA;AACE;AACV;;;AAGY;;AAEF;;;AAGE;AACF;;;;;;;;;;AAUE;;;AAGA;;;;;AAKF;AACF;AACR;;;AAGQ;;AAEA;AACE;;;AAGE;AACF;AACA;;;;AAIA;AACF;AACR;;AAEM;;;AAGI;AACF;;AAEA;AACA;AACE;AACF;;AAEA;;;;AAIE;;AAEA;AACE;AACF;;AAEV;AACU;;AAEA;;AAEV;AACU;AACA;AACE;AACgG;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;;;AAGA;;AAEA;AACA;AACA;AACA;;;AAGA;;"}